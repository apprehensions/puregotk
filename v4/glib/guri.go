// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
)

// The #GUri type and related functions can be used to parse URIs into
// their components, and build valid URIs from individual components.
//
// Note that #GUri scope is to help manipulate URIs in various applications,
// following [RFC 3986](https://tools.ietf.org/html/rfc3986). In particular,
// it doesn't intend to cover web browser needs, and doesn't implement the
// [WHATWG URL](https://url.spec.whatwg.org/) standard. No APIs are provided to
// help prevent
// [homograph attacks](https://en.wikipedia.org/wiki/IDN_homograph_attack), so
// #GUri is not suitable for formatting URIs for display to the user for making
// security-sensitive decisions.
//
// ## Relative and absolute URIs # {#relative-absolute-uris}
//
// As defined in [RFC 3986](https://tools.ietf.org/html/rfc3986#section-4), the
// hierarchical nature of URIs means that they can either be ‘relative
// references’ (sometimes referred to as ‘relative URIs’) or ‘URIs’ (for
// clarity, ‘URIs’ are referred to in this documentation as
// ‘absolute URIs’ — although
// [in constrast to RFC 3986](https://tools.ietf.org/html/rfc3986#section-4.3),
// fragment identifiers are always allowed).
//
// Relative references have one or more components of the URI missing. In
// particular, they have no scheme. Any other component, such as hostname,
// query, etc. may be missing, apart from a path, which has to be specified (but
// may be empty). The path may be relative, starting with `./` rather than `/`.
//
// For example, a valid relative reference is `./path?query`,
// `/?query#fragment` or `//example.com`.
//
// Absolute URIs have a scheme specified. Any other components of the URI which
// are missing are specified as explicitly unset in the URI, rather than being
// resolved relative to a base URI using g_uri_parse_relative().
//
// For example, a valid absolute URI is `file:///home/bob` or
// `https://search.com?query=string`.
//
// A #GUri instance is always an absolute URI. A string may be an absolute URI
// or a relative reference; see the documentation for individual functions as to
// what forms they accept.
//
// ## Parsing URIs
//
// The most minimalist APIs for parsing URIs are g_uri_split() and
// g_uri_split_with_user(). These split a URI into its component
// parts, and return the parts; the difference between the two is that
// g_uri_split() treats the ‘userinfo’ component of the URI as a
// single element, while g_uri_split_with_user() can (depending on the
// #GUriFlags you pass) treat it as containing a username, password,
// and authentication parameters. Alternatively, g_uri_split_network()
// can be used when you are only interested in the components that are
// needed to initiate a network connection to the service (scheme,
// host, and port).
//
// g_uri_parse() is similar to g_uri_split(), but instead of returning
// individual strings, it returns a #GUri structure (and it requires
// that the URI be an absolute URI).
//
// g_uri_resolve_relative() and g_uri_parse_relative() allow you to
// resolve a relative URI relative to a base URI.
// g_uri_resolve_relative() takes two strings and returns a string,
// and g_uri_parse_relative() takes a #GUri and a string and returns a
// #GUri.
//
// All of the parsing functions take a #GUriFlags argument describing
// exactly how to parse the URI; see the documentation for that type
// for more details on the specific flags that you can pass. If you
// need to choose different flags based on the type of URI, you can
// use g_uri_peek_scheme() on the URI string to check the scheme
// first, and use that to decide what flags to parse it with.
//
// For example, you might want to use %G_URI_PARAMS_WWW_FORM when parsing the
// params for a web URI, so compare the result of g_uri_peek_scheme() against
// `http` and `https`.
//
// ## Building URIs
//
// g_uri_join() and g_uri_join_with_user() can be used to construct
// valid URI strings from a set of component strings. They are the
// inverse of g_uri_split() and g_uri_split_with_user().
//
// Similarly, g_uri_build() and g_uri_build_with_user() can be used to
// construct a #GUri from a set of component strings.
//
// As with the parsing functions, the building functions take a
// #GUriFlags argument. In particular, it is important to keep in mind
// whether the URI components you are using are already `%`-encoded. If so,
// you must pass the %G_URI_FLAGS_ENCODED flag.
//
// ## `file://` URIs
//
// Note that Windows and Unix both define special rules for parsing
// `file://` URIs (involving non-UTF-8 character sets on Unix, and the
// interpretation of path separators on Windows). #GUri does not
// implement these rules. Use g_filename_from_uri() and
// g_filename_to_uri() if you want to properly convert between
// `file://` URIs and local filenames.
//
// ## URI Equality
//
// Note that there is no `g_uri_equal ()` function, because comparing
// URIs usefully requires scheme-specific knowledge that #GUri does
// not have. #GUri can help with normalization if you use the various
// encoded #GUriFlags as well as %G_URI_FLAGS_SCHEME_NORMALIZE however
// it is not comprehensive.
// For example, `data:,foo` and `data:;base64,Zm9v` resolve to the same
// thing according to the `data:` URI specification which GLib does not
// handle.
type Uri struct {
}

// Many URI schemes include one or more attribute/value pairs as part of the URI
// value. For example `scheme://server/path?query=string&amp;is=there` has two
// attributes – `query=string` and `is=there` – in its query part.
//
// A #GUriParamsIter structure represents an iterator that can be used to
// iterate over the attribute/value pairs of a URI query string. #GUriParamsIter
// structures are typically allocated on the stack and then initialized with
// g_uri_params_iter_init(). See the documentation for g_uri_params_iter_init()
// for a usage example.
type UriParamsIter struct {
	Dummy0 int32

	Dummy1 uintptr

	Dummy2 uintptr

	Dummy3 uintptr
}

// Flags that describe a URI.
//
// When parsing a URI, if you need to choose different flags based on
// the type of URI, you can use g_uri_peek_scheme() on the URI string
// to check the scheme first, and use that to decide what flags to
// parse it with.
type UriFlags int

const (

	// No flags set.
	GUriFlagsNoneValue UriFlags = 0
	// Parse the URI more relaxedly than the
	//     [RFC 3986](https://tools.ietf.org/html/rfc3986) grammar specifies,
	//     fixing up or ignoring common mistakes in URIs coming from external
	//     sources. This is also needed for some obscure URI schemes where `;`
	//     separates the host from the path. Don’t use this flag unless you need to.
	GUriFlagsParseRelaxedValue UriFlags = 1
	// The userinfo field may contain a password,
	//     which will be separated from the username by `:`.
	GUriFlagsHasPasswordValue UriFlags = 2
	// The userinfo may contain additional
	//     authentication-related parameters, which will be separated from
	//     the username and/or password by `;`.
	GUriFlagsHasAuthParamsValue UriFlags = 4
	// When parsing a URI, this indicates that `%`-encoded
	//     characters in the userinfo, path, query, and fragment fields
	//     should not be decoded. (And likewise the host field if
	//     %G_URI_FLAGS_NON_DNS is also set.) When building a URI, it indicates
	//     that you have already `%`-encoded the components, and so #GUri
	//     should not do any encoding itself.
	GUriFlagsEncodedValue UriFlags = 8
	// The host component should not be assumed to be a
	//     DNS hostname or IP address (for example, for `smb` URIs with NetBIOS
	//     hostnames).
	GUriFlagsNonDnsValue UriFlags = 16
	// Same as %G_URI_FLAGS_ENCODED, for the query
	//     field only.
	GUriFlagsEncodedQueryValue UriFlags = 32
	// Same as %G_URI_FLAGS_ENCODED, for the path only.
	GUriFlagsEncodedPathValue UriFlags = 64
	// Same as %G_URI_FLAGS_ENCODED, for the
	//     fragment only.
	GUriFlagsEncodedFragmentValue UriFlags = 128
	// A scheme-based normalization will be applied.
	//     For example, when parsing an HTTP URI changing omitted path to `/` and
	//     omitted port to `80`; and when building a URI, changing empty path to `/`
	//     and default port `80`). This only supports a subset of known schemes. (Since: 2.68)
	GUriFlagsSchemeNormalizeValue UriFlags = 256
)

// Flags describing what parts of the URI to hide in
// g_uri_to_string_partial(). Note that %G_URI_HIDE_PASSWORD and
// %G_URI_HIDE_AUTH_PARAMS will only work if the #GUri was parsed with
// the corresponding flags.
type UriHideFlags int

const (

	// No flags set.
	GUriHideNoneValue UriHideFlags = 0
	// Hide the userinfo.
	GUriHideUserinfoValue UriHideFlags = 1
	// Hide the password.
	GUriHidePasswordValue UriHideFlags = 2
	// Hide the auth_params.
	GUriHideAuthParamsValue UriHideFlags = 4
	// Hide the query.
	GUriHideQueryValue UriHideFlags = 8
	// Hide the fragment.
	GUriHideFragmentValue UriHideFlags = 16
)

// Flags modifying the way parameters are handled by g_uri_parse_params() and
// #GUriParamsIter.
type UriParamsFlags int

const (

	// No flags set.
	GUriParamsNoneValue UriParamsFlags = 0
	// Parameter names are case insensitive.
	GUriParamsCaseInsensitiveValue UriParamsFlags = 1
	// Replace `+` with space character. Only useful for
	//     URLs on the web, using the `https` or `http` schemas.
	GUriParamsWwwFormValue UriParamsFlags = 2
	// See %G_URI_FLAGS_PARSE_RELAXED.
	GUriParamsParseRelaxedValue UriParamsFlags = 4
)

// Error codes returned by #GUri methods.
type UriError int

const (

	// Generic error if no more specific error is available.
	//     See the error message for details.
	GUriErrorFailedValue UriError = 0
	// The scheme of a URI could not be parsed.
	GUriErrorBadSchemeValue UriError = 1
	// The user/userinfo of a URI could not be parsed.
	GUriErrorBadUserValue UriError = 2
	// The password of a URI could not be parsed.
	GUriErrorBadPasswordValue UriError = 3
	// The authentication parameters of a URI could not be parsed.
	GUriErrorBadAuthParamsValue UriError = 4
	// The host of a URI could not be parsed.
	GUriErrorBadHostValue UriError = 5
	// The port of a URI could not be parsed.
	GUriErrorBadPortValue UriError = 6
	// The path of a URI could not be parsed.
	GUriErrorBadPathValue UriError = 7
	// The query of a URI could not be parsed.
	GUriErrorBadQueryValue UriError = 8
	// The fragment of a URI could not be parsed.
	GUriErrorBadFragmentValue UriError = 9
)

var xUriBuild func(UriFlags, string, string, string, int, string, string, string) *Uri

// Creates a new #GUri from the given components according to @flags.
//
// See also g_uri_build_with_user(), which allows specifying the
// components of the "userinfo" separately.
func UriBuild(FlagsVar UriFlags, SchemeVar string, UserinfoVar string, HostVar string, PortVar int, PathVar string, QueryVar string, FragmentVar string) *Uri {

	return xUriBuild(FlagsVar, SchemeVar, UserinfoVar, HostVar, PortVar, PathVar, QueryVar, FragmentVar)

}

var xUriBuildWithUser func(UriFlags, string, string, string, string, string, int, string, string, string) *Uri

// Creates a new #GUri from the given components according to @flags
// (%G_URI_FLAGS_HAS_PASSWORD is added unconditionally). The @flags must be
// coherent with the passed values, in particular use `%`-encoded values with
// %G_URI_FLAGS_ENCODED.
//
// In contrast to g_uri_build(), this allows specifying the components
// of the ‘userinfo’ field separately. Note that @user must be non-%NULL
// if either @password or @auth_params is non-%NULL.
func UriBuildWithUser(FlagsVar UriFlags, SchemeVar string, UserVar string, PasswordVar string, AuthParamsVar string, HostVar string, PortVar int, PathVar string, QueryVar string, FragmentVar string) *Uri {

	return xUriBuildWithUser(FlagsVar, SchemeVar, UserVar, PasswordVar, AuthParamsVar, HostVar, PortVar, PathVar, QueryVar, FragmentVar)

}

var xUriEscapeBytes func(uintptr, uint, string) string

// Escapes arbitrary data for use in a URI.
//
// Normally all characters that are not ‘unreserved’ (i.e. ASCII
// alphanumerical characters plus dash, dot, underscore and tilde) are
// escaped. But if you specify characters in @reserved_chars_allowed
// they are not escaped. This is useful for the ‘reserved’ characters
// in the URI specification, since those are allowed unescaped in some
// portions of a URI.
//
// Though technically incorrect, this will also allow escaping nul
// bytes as `%“00`.
func UriEscapeBytes(UnescapedVar uintptr, LengthVar uint, ReservedCharsAllowedVar string) string {

	return xUriEscapeBytes(UnescapedVar, LengthVar, ReservedCharsAllowedVar)

}

var xUriEscapeString func(string, string, bool) string

// Escapes a string for use in a URI.
//
// Normally all characters that are not "unreserved" (i.e. ASCII
// alphanumerical characters plus dash, dot, underscore and tilde) are
// escaped. But if you specify characters in @reserved_chars_allowed
// they are not escaped. This is useful for the "reserved" characters
// in the URI specification, since those are allowed unescaped in some
// portions of a URI.
func UriEscapeString(UnescapedVar string, ReservedCharsAllowedVar string, AllowUtf8Var bool) string {

	return xUriEscapeString(UnescapedVar, ReservedCharsAllowedVar, AllowUtf8Var)

}

var xUriIsValid func(string, UriFlags) bool

// Parses @uri_string according to @flags, to determine whether it is a valid
// [absolute URI][relative-absolute-uris], i.e. it does not need to be resolved
// relative to another URI using g_uri_parse_relative().
//
// If it’s not a valid URI, an error is returned explaining how it’s invalid.
//
// See g_uri_split(), and the definition of #GUriFlags, for more
// information on the effect of @flags.
func UriIsValid(UriStringVar string, FlagsVar UriFlags) bool {

	return xUriIsValid(UriStringVar, FlagsVar)

}

var xUriJoin func(UriFlags, string, string, string, int, string, string, string) string

// Joins the given components together according to @flags to create
// an absolute URI string. @path may not be %NULL (though it may be the empty
// string).
//
// When @host is present, @path must either be empty or begin with a slash (`/`)
// character. When @host is not present, @path cannot begin with two slash
//
//	characters (`//`). See
//
// [RFC 3986, section 3](https://tools.ietf.org/html/rfc3986#section-3).
//
// See also g_uri_join_with_user(), which allows specifying the
// components of the ‘userinfo’ separately.
//
// %G_URI_FLAGS_HAS_PASSWORD and %G_URI_FLAGS_HAS_AUTH_PARAMS are ignored if set
// in @flags.
func UriJoin(FlagsVar UriFlags, SchemeVar string, UserinfoVar string, HostVar string, PortVar int, PathVar string, QueryVar string, FragmentVar string) string {

	return xUriJoin(FlagsVar, SchemeVar, UserinfoVar, HostVar, PortVar, PathVar, QueryVar, FragmentVar)

}

var xUriJoinWithUser func(UriFlags, string, string, string, string, string, int, string, string, string) string

// Joins the given components together according to @flags to create
// an absolute URI string. @path may not be %NULL (though it may be the empty
// string).
//
// In contrast to g_uri_join(), this allows specifying the components
// of the ‘userinfo’ separately. It otherwise behaves the same.
//
// %G_URI_FLAGS_HAS_PASSWORD and %G_URI_FLAGS_HAS_AUTH_PARAMS are ignored if set
// in @flags.
func UriJoinWithUser(FlagsVar UriFlags, SchemeVar string, UserVar string, PasswordVar string, AuthParamsVar string, HostVar string, PortVar int, PathVar string, QueryVar string, FragmentVar string) string {

	return xUriJoinWithUser(FlagsVar, SchemeVar, UserVar, PasswordVar, AuthParamsVar, HostVar, PortVar, PathVar, QueryVar, FragmentVar)

}

var xUriParse func(string, UriFlags) *Uri

// Parses @uri_string according to @flags. If the result is not a
// valid [absolute URI][relative-absolute-uris], it will be discarded, and an
// error returned.
func UriParse(UriStringVar string, FlagsVar UriFlags) *Uri {

	return xUriParse(UriStringVar, FlagsVar)

}

var xUriParseParams func(string, int, string, UriParamsFlags) *HashTable

// Many URI schemes include one or more attribute/value pairs as part of the URI
// value. This method can be used to parse them into a hash table. When an
// attribute has multiple occurrences, the last value is the final returned
// value. If you need to handle repeated attributes differently, use
// #GUriParamsIter.
//
// The @params string is assumed to still be `%`-encoded, but the returned
// values will be fully decoded. (Thus it is possible that the returned values
// may contain `=` or @separators, if the value was encoded in the input.)
// Invalid `%`-encoding is treated as with the %G_URI_FLAGS_PARSE_RELAXED
// rules for g_uri_parse(). (However, if @params is the path or query string
// from a #GUri that was parsed without %G_URI_FLAGS_PARSE_RELAXED and
// %G_URI_FLAGS_ENCODED, then you already know that it does not contain any
// invalid encoding.)
//
// %G_URI_PARAMS_WWW_FORM is handled as documented for g_uri_params_iter_init().
//
// If %G_URI_PARAMS_CASE_INSENSITIVE is passed to @flags, attributes will be
// compared case-insensitively, so a params string `attr=123&amp;Attr=456` will only
// return a single attribute–value pair, `Attr=456`. Case will be preserved in
// the returned attributes.
//
// If @params cannot be parsed (for example, it contains two @separators
// characters in a row), then @error is set and %NULL is returned.
func UriParseParams(ParamsVar string, LengthVar int, SeparatorsVar string, FlagsVar UriParamsFlags) *HashTable {

	return xUriParseParams(ParamsVar, LengthVar, SeparatorsVar, FlagsVar)

}

var xUriParseScheme func(string) string

// Gets the scheme portion of a URI string.
// [RFC 3986](https://tools.ietf.org/html/rfc3986#section-3) decodes the scheme
// as:
// |[
// URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
// ]|
// Common schemes include `file`, `https`, `svn+ssh`, etc.
func UriParseScheme(UriVar string) string {

	return xUriParseScheme(UriVar)

}

var xUriPeekScheme func(string) string

// Gets the scheme portion of a URI string.
// [RFC 3986](https://tools.ietf.org/html/rfc3986#section-3) decodes the scheme
// as:
// |[
// URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
// ]|
// Common schemes include `file`, `https`, `svn+ssh`, etc.
//
// Unlike g_uri_parse_scheme(), the returned scheme is normalized to
// all-lowercase and does not need to be freed.
func UriPeekScheme(UriVar string) string {

	return xUriPeekScheme(UriVar)

}

var xUriResolveRelative func(string, string, UriFlags) string

// Parses @uri_ref according to @flags and, if it is a
// [relative URI][relative-absolute-uris], resolves it relative to
// @base_uri_string. If the result is not a valid absolute URI, it will be
// discarded, and an error returned.
//
// (If @base_uri_string is %NULL, this just returns @uri_ref, or
// %NULL if @uri_ref is invalid or not absolute.)
func UriResolveRelative(BaseUriStringVar string, UriRefVar string, FlagsVar UriFlags) string {

	return xUriResolveRelative(BaseUriStringVar, UriRefVar, FlagsVar)

}

var xUriSplit func(string, UriFlags, string, string, string, int, string, string, string) bool

// Parses @uri_ref (which can be an
// [absolute or relative URI][relative-absolute-uris]) according to @flags, and
// returns the pieces. Any component that doesn't appear in @uri_ref will be
// returned as %NULL (but note that all URIs always have a path component,
// though it may be the empty string).
//
// If @flags contains %G_URI_FLAGS_ENCODED, then `%`-encoded characters in
// @uri_ref will remain encoded in the output strings. (If not,
// then all such characters will be decoded.) Note that decoding will
// only work if the URI components are ASCII or UTF-8, so you will
// need to use %G_URI_FLAGS_ENCODED if they are not.
//
// Note that the %G_URI_FLAGS_HAS_PASSWORD and
// %G_URI_FLAGS_HAS_AUTH_PARAMS @flags are ignored by g_uri_split(),
// since it always returns only the full userinfo; use
// g_uri_split_with_user() if you want it split up.
func UriSplit(UriRefVar string, FlagsVar UriFlags, SchemeVar string, UserinfoVar string, HostVar string, PortVar int, PathVar string, QueryVar string, FragmentVar string) bool {

	return xUriSplit(UriRefVar, FlagsVar, SchemeVar, UserinfoVar, HostVar, PortVar, PathVar, QueryVar, FragmentVar)

}

var xUriSplitNetwork func(string, UriFlags, string, string, int) bool

// Parses @uri_string (which must be an [absolute URI][relative-absolute-uris])
// according to @flags, and returns the pieces relevant to connecting to a host.
// See the documentation for g_uri_split() for more details; this is
// mostly a wrapper around that function with simpler arguments.
// However, it will return an error if @uri_string is a relative URI,
// or does not contain a hostname component.
func UriSplitNetwork(UriStringVar string, FlagsVar UriFlags, SchemeVar string, HostVar string, PortVar int) bool {

	return xUriSplitNetwork(UriStringVar, FlagsVar, SchemeVar, HostVar, PortVar)

}

var xUriSplitWithUser func(string, UriFlags, string, string, string, string, string, int, string, string, string) bool

// Parses @uri_ref (which can be an
// [absolute or relative URI][relative-absolute-uris]) according to @flags, and
// returns the pieces. Any component that doesn't appear in @uri_ref will be
// returned as %NULL (but note that all URIs always have a path component,
// though it may be the empty string).
//
// See g_uri_split(), and the definition of #GUriFlags, for more
// information on the effect of @flags. Note that @password will only
// be parsed out if @flags contains %G_URI_FLAGS_HAS_PASSWORD, and
// @auth_params will only be parsed out if @flags contains
// %G_URI_FLAGS_HAS_AUTH_PARAMS.
func UriSplitWithUser(UriRefVar string, FlagsVar UriFlags, SchemeVar string, UserVar string, PasswordVar string, AuthParamsVar string, HostVar string, PortVar int, PathVar string, QueryVar string, FragmentVar string) bool {

	return xUriSplitWithUser(UriRefVar, FlagsVar, SchemeVar, UserVar, PasswordVar, AuthParamsVar, HostVar, PortVar, PathVar, QueryVar, FragmentVar)

}

var xUriUnescapeBytes func(string, int, string) *Bytes

// Unescapes a segment of an escaped string as binary data.
//
// Note that in contrast to g_uri_unescape_string(), this does allow
// nul bytes to appear in the output.
//
// If any of the characters in @illegal_characters appears as an escaped
// character in @escaped_string, then that is an error and %NULL will be
// returned. This is useful if you want to avoid for instance having a slash
// being expanded in an escaped path element, which might confuse pathname
// handling.
func UriUnescapeBytes(EscapedStringVar string, LengthVar int, IllegalCharactersVar string) *Bytes {

	return xUriUnescapeBytes(EscapedStringVar, LengthVar, IllegalCharactersVar)

}

var xUriUnescapeSegment func(string, string, string) string

// Unescapes a segment of an escaped string.
//
// If any of the characters in @illegal_characters or the NUL
// character appears as an escaped character in @escaped_string, then
// that is an error and %NULL will be returned. This is useful if you
// want to avoid for instance having a slash being expanded in an
// escaped path element, which might confuse pathname handling.
//
// Note: `NUL` byte is not accepted in the output, in contrast to
// g_uri_unescape_bytes().
func UriUnescapeSegment(EscapedStringVar string, EscapedStringEndVar string, IllegalCharactersVar string) string {

	return xUriUnescapeSegment(EscapedStringVar, EscapedStringEndVar, IllegalCharactersVar)

}

var xUriUnescapeString func(string, string) string

// Unescapes a whole escaped string.
//
// If any of the characters in @illegal_characters or the NUL
// character appears as an escaped character in @escaped_string, then
// that is an error and %NULL will be returned. This is useful if you
// want to avoid for instance having a slash being expanded in an
// escaped path element, which might confuse pathname handling.
func UriUnescapeString(EscapedStringVar string, IllegalCharactersVar string) string {

	return xUriUnescapeString(EscapedStringVar, IllegalCharactersVar)

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GLIB"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}
	core.PuregoSafeRegister(&xUriBuild, lib, "g_uri_build")
	core.PuregoSafeRegister(&xUriBuildWithUser, lib, "g_uri_build_with_user")
	core.PuregoSafeRegister(&xUriEscapeBytes, lib, "g_uri_escape_bytes")
	core.PuregoSafeRegister(&xUriEscapeString, lib, "g_uri_escape_string")
	core.PuregoSafeRegister(&xUriIsValid, lib, "g_uri_is_valid")
	core.PuregoSafeRegister(&xUriJoin, lib, "g_uri_join")
	core.PuregoSafeRegister(&xUriJoinWithUser, lib, "g_uri_join_with_user")
	core.PuregoSafeRegister(&xUriParse, lib, "g_uri_parse")
	core.PuregoSafeRegister(&xUriParseParams, lib, "g_uri_parse_params")
	core.PuregoSafeRegister(&xUriParseScheme, lib, "g_uri_parse_scheme")
	core.PuregoSafeRegister(&xUriPeekScheme, lib, "g_uri_peek_scheme")
	core.PuregoSafeRegister(&xUriResolveRelative, lib, "g_uri_resolve_relative")
	core.PuregoSafeRegister(&xUriSplit, lib, "g_uri_split")
	core.PuregoSafeRegister(&xUriSplitNetwork, lib, "g_uri_split_network")
	core.PuregoSafeRegister(&xUriSplitWithUser, lib, "g_uri_split_with_user")
	core.PuregoSafeRegister(&xUriUnescapeBytes, lib, "g_uri_unescape_bytes")
	core.PuregoSafeRegister(&xUriUnescapeSegment, lib, "g_uri_unescape_segment")
	core.PuregoSafeRegister(&xUriUnescapeString, lib, "g_uri_unescape_string")

}
