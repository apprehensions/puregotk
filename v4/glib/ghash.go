// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
)

// Specifies the type of the function passed to
// g_hash_table_foreach_remove(). It is called with each key/value
// pair, together with the @user_data parameter passed to
// g_hash_table_foreach_remove(). It should return %TRUE if the
// key/value pair should be removed from the #GHashTable.
type HRFunc func(uintptr, uintptr, uintptr) bool

// The #GHashTable struct is an opaque data structure to represent a
// [Hash Table][glib-Hash-Tables]. It should only be accessed via the
// following functions.
type HashTable struct {
}

// A GHashTableIter structure represents an iterator that can be used
// to iterate over the elements of a #GHashTable. GHashTableIter
// structures are typically allocated on the stack and then initialized
// with g_hash_table_iter_init().
//
// The iteration order of a #GHashTableIter over the keys/values in a hash
// table is not defined.
type HashTableIter struct {
	Dummy1 uintptr

	Dummy2 uintptr

	Dummy3 uintptr

	Dummy4 int32

	Dummy5 bool

	Dummy6 uintptr
}

var xDirectEqual func(uintptr, uintptr) bool

// Compares two #gpointer arguments and returns %TRUE if they are equal.
// It can be passed to g_hash_table_new() as the @key_equal_func
// parameter, when using opaque pointers compared by pointer value as
// keys in a #GHashTable.
//
// This equality function is also appropriate for keys that are integers
// stored in pointers, such as `GINT_TO_POINTER (n)`.
func DirectEqual(V1Var uintptr, V2Var uintptr) bool {

	return xDirectEqual(V1Var, V2Var)

}

var xDirectHash func(uintptr) uint

// Converts a gpointer to a hash value.
// It can be passed to g_hash_table_new() as the @hash_func parameter,
// when using opaque pointers compared by pointer value as keys in a
// #GHashTable.
//
// This hash function is also appropriate for keys that are integers
// stored in pointers, such as `GINT_TO_POINTER (n)`.
func DirectHash(VVar uintptr) uint {

	return xDirectHash(VVar)

}

var xDoubleEqual func(uintptr, uintptr) bool

// Compares the two #gdouble values being pointed to and returns
// %TRUE if they are equal.
// It can be passed to g_hash_table_new() as the @key_equal_func
// parameter, when using non-%NULL pointers to doubles as keys in a
// #GHashTable.
func DoubleEqual(V1Var uintptr, V2Var uintptr) bool {

	return xDoubleEqual(V1Var, V2Var)

}

var xDoubleHash func(uintptr) uint

// Converts a pointer to a #gdouble to a hash value.
// It can be passed to g_hash_table_new() as the @hash_func parameter,
// It can be passed to g_hash_table_new() as the @hash_func parameter,
// when using non-%NULL pointers to doubles as keys in a #GHashTable.
func DoubleHash(VVar uintptr) uint {

	return xDoubleHash(VVar)

}

var xHashTableAdd func(*HashTable, uintptr) bool

// This is a convenience function for using a #GHashTable as a set.  It
// is equivalent to calling g_hash_table_replace() with @key as both the
// key and the value.
//
// In particular, this means that if @key already exists in the hash table, then
// the old copy of @key in the hash table is freed and @key replaces it in the
// table.
//
// When a hash table only ever contains keys that have themselves as the
// corresponding value it is able to be stored more efficiently.  See
// the discussion in the section description.
//
// Starting from GLib 2.40, this function returns a boolean value to
// indicate whether the newly added value was already in the hash table
// or not.
func HashTableAdd(HashTableVar *HashTable, KeyVar uintptr) bool {

	return xHashTableAdd(HashTableVar, KeyVar)

}

var xHashTableContains func(*HashTable, uintptr) bool

// Checks if @key is in @hash_table.
func HashTableContains(HashTableVar *HashTable, KeyVar uintptr) bool {

	return xHashTableContains(HashTableVar, KeyVar)

}

var xHashTableDestroy func(*HashTable)

// Destroys all keys and values in the #GHashTable and decrements its
// reference count by 1. If keys and/or values are dynamically allocated,
// you should either free them first or create the #GHashTable with destroy
// notifiers using g_hash_table_new_full(). In the latter case the destroy
// functions you supplied will be called on all keys and values during the
// destruction phase.
func HashTableDestroy(HashTableVar *HashTable) {

	xHashTableDestroy(HashTableVar)

}

var xHashTableInsert func(*HashTable, uintptr, uintptr) bool

// Inserts a new key and value into a #GHashTable.
//
// If the key already exists in the #GHashTable its current
// value is replaced with the new value. If you supplied a
// @value_destroy_func when creating the #GHashTable, the old
// value is freed using that function. If you supplied a
// @key_destroy_func when creating the #GHashTable, the passed
// key is freed using that function.
//
// Starting from GLib 2.40, this function returns a boolean value to
// indicate whether the newly added value was already in the hash table
// or not.
func HashTableInsert(HashTableVar *HashTable, KeyVar uintptr, ValueVar uintptr) bool {

	return xHashTableInsert(HashTableVar, KeyVar, ValueVar)

}

var xHashTableLookup func(*HashTable, uintptr) uintptr

// Looks up a key in a #GHashTable. Note that this function cannot
// distinguish between a key that is not present and one which is present
// and has the value %NULL. If you need this distinction, use
// g_hash_table_lookup_extended().
func HashTableLookup(HashTableVar *HashTable, KeyVar uintptr) uintptr {

	return xHashTableLookup(HashTableVar, KeyVar)

}

var xHashTableLookupExtended func(*HashTable, uintptr, uintptr, uintptr) bool

// Looks up a key in the #GHashTable, returning the original key and the
// associated value and a #gboolean which is %TRUE if the key was found. This
// is useful if you need to free the memory allocated for the original key,
// for example before calling g_hash_table_remove().
//
// You can actually pass %NULL for @lookup_key to test
// whether the %NULL key exists, provided the hash and equal functions
// of @hash_table are %NULL-safe.
func HashTableLookupExtended(HashTableVar *HashTable, LookupKeyVar uintptr, OrigKeyVar uintptr, ValueVar uintptr) bool {

	return xHashTableLookupExtended(HashTableVar, LookupKeyVar, OrigKeyVar, ValueVar)

}

var xHashTableNewSimilar func(*HashTable) *HashTable

// Creates a new #GHashTable like g_hash_table_new_full() with a reference
// count of 1.
//
// It inherits the hash function, the key equal function, the key destroy function,
// as well as the value destroy function, from @other_hash_table.
//
// The returned hash table will be empty; it will not contain the keys
// or values from @other_hash_table.
func HashTableNewSimilar(OtherHashTableVar *HashTable) *HashTable {

	return xHashTableNewSimilar(OtherHashTableVar)

}

var xHashTableRemove func(*HashTable, uintptr) bool

// Removes a key and its associated value from a #GHashTable.
//
// If the #GHashTable was created using g_hash_table_new_full(), the
// key and value are freed using the supplied destroy functions, otherwise
// you have to make sure that any dynamically allocated values are freed
// yourself.
func HashTableRemove(HashTableVar *HashTable, KeyVar uintptr) bool {

	return xHashTableRemove(HashTableVar, KeyVar)

}

var xHashTableRemoveAll func(*HashTable)

// Removes all keys and their associated values from a #GHashTable.
//
// If the #GHashTable was created using g_hash_table_new_full(),
// the keys and values are freed using the supplied destroy functions,
// otherwise you have to make sure that any dynamically allocated
// values are freed yourself.
func HashTableRemoveAll(HashTableVar *HashTable) {

	xHashTableRemoveAll(HashTableVar)

}

var xHashTableReplace func(*HashTable, uintptr, uintptr) bool

// Inserts a new key and value into a #GHashTable similar to
// g_hash_table_insert(). The difference is that if the key
// already exists in the #GHashTable, it gets replaced by the
// new key. If you supplied a @value_destroy_func when creating
// the #GHashTable, the old value is freed using that function.
// If you supplied a @key_destroy_func when creating the
// #GHashTable, the old key is freed using that function.
//
// Starting from GLib 2.40, this function returns a boolean value to
// indicate whether the newly added value was already in the hash table
// or not.
func HashTableReplace(HashTableVar *HashTable, KeyVar uintptr, ValueVar uintptr) bool {

	return xHashTableReplace(HashTableVar, KeyVar, ValueVar)

}

var xHashTableSize func(*HashTable) uint

// Returns the number of elements contained in the #GHashTable.
func HashTableSize(HashTableVar *HashTable) uint {

	return xHashTableSize(HashTableVar)

}

var xHashTableSteal func(*HashTable, uintptr) bool

// Removes a key and its associated value from a #GHashTable without
// calling the key and value destroy functions.
func HashTableSteal(HashTableVar *HashTable, KeyVar uintptr) bool {

	return xHashTableSteal(HashTableVar, KeyVar)

}

var xHashTableStealAll func(*HashTable)

// Removes all keys and their associated values from a #GHashTable
// without calling the key and value destroy functions.
func HashTableStealAll(HashTableVar *HashTable) {

	xHashTableStealAll(HashTableVar)

}

var xHashTableStealExtended func(*HashTable, uintptr, uintptr, uintptr) bool

// Looks up a key in the #GHashTable, stealing the original key and the
// associated value and returning %TRUE if the key was found. If the key was
// not found, %FALSE is returned.
//
// If found, the stolen key and value are removed from the hash table without
// calling the key and value destroy functions, and ownership is transferred to
// the caller of this method; as with g_hash_table_steal().
//
// You can pass %NULL for @lookup_key, provided the hash and equal functions
// of @hash_table are %NULL-safe.
func HashTableStealExtended(HashTableVar *HashTable, LookupKeyVar uintptr, StolenKeyVar uintptr, StolenValueVar uintptr) bool {

	return xHashTableStealExtended(HashTableVar, LookupKeyVar, StolenKeyVar, StolenValueVar)

}

var xHashTableUnref func(*HashTable)

// Atomically decrements the reference count of @hash_table by one.
// If the reference count drops to 0, all keys and values will be
// destroyed, and all memory allocated by the hash table is released.
// This function is MT-safe and may be called from any thread.
func HashTableUnref(HashTableVar *HashTable) {

	xHashTableUnref(HashTableVar)

}

var xInt64Equal func(uintptr, uintptr) bool

// Compares the two #gint64 values being pointed to and returns
// %TRUE if they are equal.
// It can be passed to g_hash_table_new() as the @key_equal_func
// parameter, when using non-%NULL pointers to 64-bit integers as keys in a
// #GHashTable.
func Int64Equal(V1Var uintptr, V2Var uintptr) bool {

	return xInt64Equal(V1Var, V2Var)

}

var xInt64Hash func(uintptr) uint

// Converts a pointer to a #gint64 to a hash value.
//
// It can be passed to g_hash_table_new() as the @hash_func parameter,
// when using non-%NULL pointers to 64-bit integer values as keys in a
// #GHashTable.
func Int64Hash(VVar uintptr) uint {

	return xInt64Hash(VVar)

}

var xIntEqual func(uintptr, uintptr) bool

// Compares the two #gint values being pointed to and returns
// %TRUE if they are equal.
// It can be passed to g_hash_table_new() as the @key_equal_func
// parameter, when using non-%NULL pointers to integers as keys in a
// #GHashTable.
//
// Note that this function acts on pointers to #gint, not on #gint
// directly: if your hash table's keys are of the form
// `GINT_TO_POINTER (n)`, use g_direct_equal() instead.
func IntEqual(V1Var uintptr, V2Var uintptr) bool {

	return xIntEqual(V1Var, V2Var)

}

var xIntHash func(uintptr) uint

// Converts a pointer to a #gint to a hash value.
// It can be passed to g_hash_table_new() as the @hash_func parameter,
// when using non-%NULL pointers to integer values as keys in a #GHashTable.
//
// Note that this function acts on pointers to #gint, not on #gint
// directly: if your hash table's keys are of the form
// `GINT_TO_POINTER (n)`, use g_direct_hash() instead.
func IntHash(VVar uintptr) uint {

	return xIntHash(VVar)

}

var xStrEqual func(uintptr, uintptr) bool

// Compares two strings for byte-by-byte equality and returns %TRUE
// if they are equal. It can be passed to g_hash_table_new() as the
// @key_equal_func parameter, when using non-%NULL strings as keys in a
// #GHashTable.
//
// This function is typically used for hash table comparisons, but can be used
// for general purpose comparisons of non-%NULL strings. For a %NULL-safe string
// comparison function, see g_strcmp0().
func StrEqual(V1Var uintptr, V2Var uintptr) bool {

	return xStrEqual(V1Var, V2Var)

}

var xStrHash func(uintptr) uint

// Converts a string to a hash value.
//
// This function implements the widely used "djb" hash apparently
// posted by Daniel Bernstein to comp.lang.c some time ago.  The 32
// bit unsigned hash value starts at 5381 and for each byte 'c' in
// the string, is updated: `hash = hash * 33 + c`. This function
// uses the signed value of each byte.
//
// It can be passed to g_hash_table_new() as the @hash_func parameter,
// when using non-%NULL strings as keys in a #GHashTable.
//
// Note that this function may not be a perfect fit for all use cases.
// For example, it produces some hash collisions with strings as short
// as 2.
func StrHash(VVar uintptr) uint {

	return xStrHash(VVar)

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GLIB"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}
	core.PuregoSafeRegister(&xDirectEqual, lib, "g_direct_equal")
	core.PuregoSafeRegister(&xDirectHash, lib, "g_direct_hash")
	core.PuregoSafeRegister(&xDoubleEqual, lib, "g_double_equal")
	core.PuregoSafeRegister(&xDoubleHash, lib, "g_double_hash")
	core.PuregoSafeRegister(&xHashTableAdd, lib, "g_hash_table_add")
	core.PuregoSafeRegister(&xHashTableContains, lib, "g_hash_table_contains")
	core.PuregoSafeRegister(&xHashTableDestroy, lib, "g_hash_table_destroy")
	core.PuregoSafeRegister(&xHashTableInsert, lib, "g_hash_table_insert")
	core.PuregoSafeRegister(&xHashTableLookup, lib, "g_hash_table_lookup")
	core.PuregoSafeRegister(&xHashTableLookupExtended, lib, "g_hash_table_lookup_extended")
	core.PuregoSafeRegister(&xHashTableNewSimilar, lib, "g_hash_table_new_similar")
	core.PuregoSafeRegister(&xHashTableRemove, lib, "g_hash_table_remove")
	core.PuregoSafeRegister(&xHashTableRemoveAll, lib, "g_hash_table_remove_all")
	core.PuregoSafeRegister(&xHashTableReplace, lib, "g_hash_table_replace")
	core.PuregoSafeRegister(&xHashTableSize, lib, "g_hash_table_size")
	core.PuregoSafeRegister(&xHashTableSteal, lib, "g_hash_table_steal")
	core.PuregoSafeRegister(&xHashTableStealAll, lib, "g_hash_table_steal_all")
	core.PuregoSafeRegister(&xHashTableStealExtended, lib, "g_hash_table_steal_extended")
	core.PuregoSafeRegister(&xHashTableUnref, lib, "g_hash_table_unref")
	core.PuregoSafeRegister(&xInt64Equal, lib, "g_int64_equal")
	core.PuregoSafeRegister(&xInt64Hash, lib, "g_int64_hash")
	core.PuregoSafeRegister(&xIntEqual, lib, "g_int_equal")
	core.PuregoSafeRegister(&xIntHash, lib, "g_int_hash")
	core.PuregoSafeRegister(&xStrEqual, lib, "g_str_equal")
	core.PuregoSafeRegister(&xStrHash, lib, "g_str_hash")

}
