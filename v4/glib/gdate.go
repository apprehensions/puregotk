// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
)

// Represents a day between January 1, Year 1 and a few thousand years in
// the future. None of its members should be accessed directly.
//
// If the `GDate` is obtained from g_date_new(), it will be safe
// to mutate but invalid and thus not safe for calendrical computations.
//
// If it's declared on the stack, it will contain garbage so must be
// initialized with g_date_clear(). g_date_clear() makes the date invalid
// but safe. An invalid date doesn't represent a day, it's "empty." A date
// becomes valid after you set it to a Julian day or you set a day, month,
// and year.
type Date struct {
	JulianDays uint

	Julian uint

	Dmy uint

	Day uint

	Month uint

	Year uint
}

// Integer representing a day of the month; between 1 and 31.
//
// The %G_DATE_BAD_DAY value represents an invalid day of the month.
type DateDay = byte

// Integer type representing a year.
//
// The %G_DATE_BAD_YEAR value is the invalid value. The year
// must be 1 or higher; negative ([BCE](https://en.wikipedia.org/wiki/Common_Era))
// years are not allowed.
//
// The year is represented with four digits.
type DateYear = uint16

// Simply a replacement for `time_t`. It has been deprecated
// since it is not equivalent to `time_t` on 64-bit platforms
// with a 64-bit `time_t`.
//
// Unrelated to #GTimer.
//
// Note that #GTime is defined to always be a 32-bit integer,
// unlike `time_t` which may be 64-bit on some systems. Therefore,
// #GTime will overflow in the year 2038, and you cannot use the
// address of a #GTime variable as argument to the UNIX time()
// function.
//
// Instead, do the following:
//
// |[&lt;!-- language="C" --&gt;
// time_t ttime;
// GTime gtime;
//
// time (&amp;ttime);
// gtime = (GTime)ttime;
// ]|
type Time = int32

// This enumeration isn't used in the API, but may be useful if you need
// to mark a number as a day, month, or year.
type DateDMY int

const (

	// a day
	GDateDayValue DateDMY = 0
	// a month
	GDateMonthValue DateDMY = 1
	// a year
	GDateYearValue DateDMY = 2
)

// Enumeration representing a month; values are %G_DATE_JANUARY,
// %G_DATE_FEBRUARY, etc. %G_DATE_BAD_MONTH is the invalid value.
type DateMonth int

const (

	// invalid value
	GDateBadMonthValue DateMonth = 0
	// January
	GDateJanuaryValue DateMonth = 1
	// February
	GDateFebruaryValue DateMonth = 2
	// March
	GDateMarchValue DateMonth = 3
	// April
	GDateAprilValue DateMonth = 4
	// May
	GDateMayValue DateMonth = 5
	// June
	GDateJuneValue DateMonth = 6
	// July
	GDateJulyValue DateMonth = 7
	// August
	GDateAugustValue DateMonth = 8
	// September
	GDateSeptemberValue DateMonth = 9
	// October
	GDateOctoberValue DateMonth = 10
	// November
	GDateNovemberValue DateMonth = 11
	// December
	GDateDecemberValue DateMonth = 12
)

// Enumeration representing a day of the week; %G_DATE_MONDAY,
// %G_DATE_TUESDAY, etc. %G_DATE_BAD_WEEKDAY is an invalid weekday.
type DateWeekday int

const (

	// invalid value
	GDateBadWeekdayValue DateWeekday = 0
	// Monday
	GDateMondayValue DateWeekday = 1
	// Tuesday
	GDateTuesdayValue DateWeekday = 2
	// Wednesday
	GDateWednesdayValue DateWeekday = 3
	// Thursday
	GDateThursdayValue DateWeekday = 4
	// Friday
	GDateFridayValue DateWeekday = 5
	// Saturday
	GDateSaturdayValue DateWeekday = 6
	// Sunday
	GDateSundayValue DateWeekday = 7
)

var xDateGetDaysInMonth func(DateMonth, DateYear) byte

// Returns the number of days in a month, taking leap
// years into account.
func DateGetDaysInMonth(MonthVar DateMonth, YearVar DateYear) byte {

	return xDateGetDaysInMonth(MonthVar, YearVar)

}

var xDateGetMondayWeeksInYear func(DateYear) byte

// Returns the number of weeks in the year, where weeks
// are taken to start on Monday. Will be 52 or 53. The
// date must be valid. (Years always have 52 7-day periods,
// plus 1 or 2 extra days depending on whether it's a leap
// year. This function is basically telling you how many
// Mondays are in the year, i.e. there are 53 Mondays if
// one of the extra days happens to be a Monday.)
func DateGetMondayWeeksInYear(YearVar DateYear) byte {

	return xDateGetMondayWeeksInYear(YearVar)

}

var xDateGetSundayWeeksInYear func(DateYear) byte

// Returns the number of weeks in the year, where weeks
// are taken to start on Sunday. Will be 52 or 53. The
// date must be valid. (Years always have 52 7-day periods,
// plus 1 or 2 extra days depending on whether it's a leap
// year. This function is basically telling you how many
// Sundays are in the year, i.e. there are 53 Sundays if
// one of the extra days happens to be a Sunday.)
func DateGetSundayWeeksInYear(YearVar DateYear) byte {

	return xDateGetSundayWeeksInYear(YearVar)

}

var xDateIsLeapYear func(DateYear) bool

// Returns %TRUE if the year is a leap year.
//
// For the purposes of this function, leap year is every year
// divisible by 4 unless that year is divisible by 100. If it
// is divisible by 100 it would be a leap year only if that year
// is also divisible by 400.
func DateIsLeapYear(YearVar DateYear) bool {

	return xDateIsLeapYear(YearVar)

}

var xDateStrftime func(string, uint, string, *Date) uint

// Generates a printed representation of the date, in a
// [locale][setlocale]-specific way.
// Works just like the platform's C library strftime() function,
// but only accepts date-related formats; time-related formats
// give undefined results. Date must be valid. Unlike strftime()
// (which uses the locale encoding), works on a UTF-8 format
// string and stores a UTF-8 result.
//
// This function does not provide any conversion specifiers in
// addition to those implemented by the platform's C library.
// For example, don't expect that using g_date_strftime() would
// make the \%F provided by the C99 strftime() work on Windows
// where the C library only complies to C89.
func DateStrftime(SVar string, SlenVar uint, FormatVar string, DateVar *Date) uint {

	return xDateStrftime(SVar, SlenVar, FormatVar, DateVar)

}

var xDateValidDay func(DateDay) bool

// Returns %TRUE if the day of the month is valid (a day is valid if it's
// between 1 and 31 inclusive).
func DateValidDay(DayVar DateDay) bool {

	return xDateValidDay(DayVar)

}

var xDateValidDmy func(DateDay, DateMonth, DateYear) bool

// Returns %TRUE if the day-month-year triplet forms a valid, existing day
// in the range of days #GDate understands (Year 1 or later, no more than
// a few thousand years in the future).
func DateValidDmy(DayVar DateDay, MonthVar DateMonth, YearVar DateYear) bool {

	return xDateValidDmy(DayVar, MonthVar, YearVar)

}

var xDateValidJulian func(uint32) bool

// Returns %TRUE if the Julian day is valid. Anything greater than zero
// is basically a valid Julian, though there is a 32-bit limit.
func DateValidJulian(JulianDateVar uint32) bool {

	return xDateValidJulian(JulianDateVar)

}

var xDateValidMonth func(DateMonth) bool

// Returns %TRUE if the month value is valid. The 12 #GDateMonth
// enumeration values are the only valid months.
func DateValidMonth(MonthVar DateMonth) bool {

	return xDateValidMonth(MonthVar)

}

var xDateValidWeekday func(DateWeekday) bool

// Returns %TRUE if the weekday is valid. The seven #GDateWeekday enumeration
// values are the only valid weekdays.
func DateValidWeekday(WeekdayVar DateWeekday) bool {

	return xDateValidWeekday(WeekdayVar)

}

var xDateValidYear func(DateYear) bool

// Returns %TRUE if the year is valid. Any year greater than 0 is valid,
// though there is a 16-bit limit to what #GDate will understand.
func DateValidYear(YearVar DateYear) bool {

	return xDateValidYear(YearVar)

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GLIB"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}
	core.PuregoSafeRegister(&xDateGetDaysInMonth, lib, "g_date_get_days_in_month")
	core.PuregoSafeRegister(&xDateGetMondayWeeksInYear, lib, "g_date_get_monday_weeks_in_year")
	core.PuregoSafeRegister(&xDateGetSundayWeeksInYear, lib, "g_date_get_sunday_weeks_in_year")
	core.PuregoSafeRegister(&xDateIsLeapYear, lib, "g_date_is_leap_year")
	core.PuregoSafeRegister(&xDateStrftime, lib, "g_date_strftime")
	core.PuregoSafeRegister(&xDateValidDay, lib, "g_date_valid_day")
	core.PuregoSafeRegister(&xDateValidDmy, lib, "g_date_valid_dmy")
	core.PuregoSafeRegister(&xDateValidJulian, lib, "g_date_valid_julian")
	core.PuregoSafeRegister(&xDateValidMonth, lib, "g_date_valid_month")
	core.PuregoSafeRegister(&xDateValidWeekday, lib, "g_date_valid_weekday")
	core.PuregoSafeRegister(&xDateValidYear, lib, "g_date_valid_year")

}
