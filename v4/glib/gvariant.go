// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
)

// #GVariant is a variant datatype; it can contain one or more values
// along with information about the type of the values.
//
// A #GVariant may contain simple types, like an integer, or a boolean value;
// or complex types, like an array of two strings, or a dictionary of key
// value pairs. A #GVariant is also immutable: once it's been created neither
// its type nor its content can be modified further.
//
// GVariant is useful whenever data needs to be serialized, for example when
// sending method parameters in D-Bus, or when saving settings using GSettings.
//
// When creating a new #GVariant, you pass the data you want to store in it
// along with a string representing the type of data you wish to pass to it.
//
// For instance, if you want to create a #GVariant holding an integer value you
// can use:
//
// |[&lt;!-- language="C" --&gt;
//
//	GVariant *v = g_variant_new ("u", 40);
//
// ]|
//
// The string "u" in the first argument tells #GVariant that the data passed to
// the constructor (40) is going to be an unsigned integer.
//
// More advanced examples of #GVariant in use can be found in documentation for
// [GVariant format strings][gvariant-format-strings-pointers].
//
// The range of possible values is determined by the type.
//
// The type system used by #GVariant is #GVariantType.
//
// #GVariant instances always have a type and a value (which are given
// at construction time).  The type and value of a #GVariant instance
// can never change other than by the #GVariant itself being
// destroyed.  A #GVariant cannot contain a pointer.
//
// #GVariant is reference counted using g_variant_ref() and
// g_variant_unref().  #GVariant also has floating reference counts --
// see g_variant_ref_sink().
//
// #GVariant is completely threadsafe.  A #GVariant instance can be
// concurrently accessed in any way from any number of threads without
// problems.
//
// #GVariant is heavily optimised for dealing with data in serialized
// form.  It works particularly well with data located in memory-mapped
// files.  It can perform nearly all deserialization operations in a
// small constant time, usually touching only a single memory page.
// Serialized #GVariant data can also be sent over the network.
//
// #GVariant is largely compatible with D-Bus.  Almost all types of
// #GVariant instances can be sent over D-Bus.  See #GVariantType for
// exceptions.  (However, #GVariant's serialization format is not the same
// as the serialization format of a D-Bus message body: use #GDBusMessage,
// in the gio library, for those.)
//
// For space-efficiency, the #GVariant serialization format does not
// automatically include the variant's length, type or endianness,
// which must either be implied from context (such as knowledge that a
// particular file format always contains a little-endian
// %G_VARIANT_TYPE_VARIANT which occupies the whole length of the file)
// or supplied out-of-band (for instance, a length, type and/or endianness
// indicator could be placed at the beginning of a file, network message
// or network stream).
//
// A #GVariant's size is limited mainly by any lower level operating
// system constraints, such as the number of bits in #gsize.  For
// example, it is reasonable to have a 2GB file mapped into memory
// with #GMappedFile, and call g_variant_new_from_data() on it.
//
// For convenience to C programmers, #GVariant features powerful
// varargs-based value construction and destruction.  This feature is
// designed to be embedded in other libraries.
//
// There is a Python-inspired text language for describing #GVariant
// values.  #GVariant includes a printer for this language and a parser
// with type inferencing.
//
// ## Memory Use
//
// #GVariant tries to be quite efficient with respect to memory use.
// This section gives a rough idea of how much memory is used by the
// current implementation.  The information here is subject to change
// in the future.
//
// The memory allocated by #GVariant can be grouped into 4 broad
// purposes: memory for serialized data, memory for the type
// information cache, buffer management memory and memory for the
// #GVariant structure itself.
//
// ## Serialized Data Memory
//
// This is the memory that is used for storing GVariant data in
// serialized form.  This is what would be sent over the network or
// what would end up on disk, not counting any indicator of the
// endianness, or of the length or type of the top-level variant.
//
// The amount of memory required to store a boolean is 1 byte. 16,
// 32 and 64 bit integers and double precision floating point numbers
// use their "natural" size.  Strings (including object path and
// signature strings) are stored with a nul terminator, and as such
// use the length of the string plus 1 byte.
//
// Maybe types use no space at all to represent the null value and
// use the same amount of space (sometimes plus one byte) as the
// equivalent non-maybe-typed value to represent the non-null case.
//
// Arrays use the amount of space required to store each of their
// members, concatenated.  Additionally, if the items stored in an
// array are not of a fixed-size (ie: strings, other arrays, etc)
// then an additional framing offset is stored for each item.  The
// size of this offset is either 1, 2 or 4 bytes depending on the
// overall size of the container.  Additionally, extra padding bytes
// are added as required for alignment of child values.
//
// Tuples (including dictionary entries) use the amount of space
// required to store each of their members, concatenated, plus one
// framing offset (as per arrays) for each non-fixed-sized item in
// the tuple, except for the last one.  Additionally, extra padding
// bytes are added as required for alignment of child values.
//
// Variants use the same amount of space as the item inside of the
// variant, plus 1 byte, plus the length of the type string for the
// item inside the variant.
//
// As an example, consider a dictionary mapping strings to variants.
// In the case that the dictionary is empty, 0 bytes are required for
// the serialization.
//
// If we add an item "width" that maps to the int32 value of 500 then
// we will use 4 byte to store the int32 (so 6 for the variant
// containing it) and 6 bytes for the string.  The variant must be
// aligned to 8 after the 6 bytes of the string, so that's 2 extra
// bytes.  6 (string) + 2 (padding) + 6 (variant) is 14 bytes used
// for the dictionary entry.  An additional 1 byte is added to the
// array as a framing offset making a total of 15 bytes.
//
// If we add another entry, "title" that maps to a nullable string
// that happens to have a value of null, then we use 0 bytes for the
// null value (and 3 bytes for the variant to contain it along with
// its type string) plus 6 bytes for the string.  Again, we need 2
// padding bytes.  That makes a total of 6 + 2 + 3 = 11 bytes.
//
// We now require extra padding between the two items in the array.
// After the 14 bytes of the first item, that's 2 bytes required.
// We now require 2 framing offsets for an extra two
// bytes. 14 + 2 + 11 + 2 = 29 bytes to encode the entire two-item
// dictionary.
//
// ## Type Information Cache
//
// For each GVariant type that currently exists in the program a type
// information structure is kept in the type information cache.  The
// type information structure is required for rapid deserialization.
//
// Continuing with the above example, if a #GVariant exists with the
// type "a{sv}" then a type information struct will exist for
// "a{sv}", "{sv}", "s", and "v".  Multiple uses of the same type
// will share the same type information.  Additionally, all
// single-digit types are stored in read-only static memory and do
// not contribute to the writable memory footprint of a program using
// #GVariant.
//
// Aside from the type information structures stored in read-only
// memory, there are two forms of type information.  One is used for
// container types where there is a single element type: arrays and
// maybe types.  The other is used for container types where there
// are multiple element types: tuples and dictionary entries.
//
// Array type info structures are 6 * sizeof (void *), plus the
// memory required to store the type string itself.  This means that
// on 32-bit systems, the cache entry for "a{sv}" would require 30
// bytes of memory (plus malloc overhead).
//
// Tuple type info structures are 6 * sizeof (void *), plus 4 *
// sizeof (void *) for each item in the tuple, plus the memory
// required to store the type string itself.  A 2-item tuple, for
// example, would have a type information structure that consumed
// writable memory in the size of 14 * sizeof (void *) (plus type
// string)  This means that on 32-bit systems, the cache entry for
// "{sv}" would require 61 bytes of memory (plus malloc overhead).
//
// This means that in total, for our "a{sv}" example, 91 bytes of
// type information would be allocated.
//
// The type information cache, additionally, uses a #GHashTable to
// store and look up the cached items and stores a pointer to this
// hash table in static storage.  The hash table is freed when there
// are zero items in the type cache.
//
// Although these sizes may seem large it is important to remember
// that a program will probably only have a very small number of
// different types of values in it and that only one type information
// structure is required for many different values of the same type.
//
// ## Buffer Management Memory
//
// #GVariant uses an internal buffer management structure to deal
// with the various different possible sources of serialized data
// that it uses.  The buffer is responsible for ensuring that the
// correct call is made when the data is no longer in use by
// #GVariant.  This may involve a g_free() or a g_slice_free() or
// even g_mapped_file_unref().
//
// One buffer management structure is used for each chunk of
// serialized data.  The size of the buffer management structure
// is 4 * (void *).  On 32-bit systems, that's 16 bytes.
//
// ## GVariant structure
//
// The size of a #GVariant structure is 6 * (void *).  On 32-bit
// systems, that's 24 bytes.
//
// #GVariant structures only exist if they are explicitly created
// with API calls.  For example, if a #GVariant is constructed out of
// serialized data for the example given above (with the dictionary)
// then although there are 9 individual values that comprise the
// entire dictionary (two keys, two values, two variants containing
// the values, two dictionary entries, plus the dictionary itself),
// only 1 #GVariant instance exists -- the one referring to the
// dictionary.
//
// If calls are made to start accessing the other values then
// #GVariant instances will exist for those values only for as long
// as they are in use (ie: until you call g_variant_unref()).  The
// type information is shared.  The serialized data and the buffer
// management structure for that serialized data is shared by the
// child.
//
// ## Summary
//
// To put the entire example together, for our dictionary mapping
// strings to variants (with two entries, as given above), we are
// using 91 bytes of memory for type information, 29 bytes of memory
// for the serialized data, 16 bytes for buffer management and 24
// bytes for the #GVariant instance, or a total of 160 bytes, plus
// malloc overhead.  If we were to use g_variant_get_child_value() to
// access the two dictionary entries, we would use an additional 48
// bytes.  If we were to have other dictionaries of the same type, we
// would use more memory for the serialized data and buffer
// management for those dictionaries, but the type information would
// be shared.
type Variant struct {
}

// A utility type for constructing container-type #GVariant instances.
//
// This is an opaque structure and may only be accessed using the
// following functions.
//
// #GVariantBuilder is not threadsafe in any way.  Do not attempt to
// access it from more than one thread.
type VariantBuilder struct {
}

// #GVariantDict is a mutable interface to #GVariant dictionaries.
//
// It can be used for doing a sequence of dictionary lookups in an
// efficient way on an existing #GVariant dictionary or it can be used
// to construct new dictionaries with a hashtable-like interface.  It
// can also be used for taking existing dictionaries and modifying them
// in order to create new ones.
//
// #GVariantDict can only be used with %G_VARIANT_TYPE_VARDICT
// dictionaries.
//
// It is possible to use #GVariantDict allocated on the stack or on the
// heap.  When using a stack-allocated #GVariantDict, you begin with a
// call to g_variant_dict_init() and free the resources with a call to
// g_variant_dict_clear().
//
// Heap-allocated #GVariantDict follows normal refcounting rules: you
// allocate it with g_variant_dict_new() and use g_variant_dict_ref()
// and g_variant_dict_unref().
//
// g_variant_dict_end() is used to convert the #GVariantDict back into a
// dictionary-type #GVariant.  When used with stack-allocated instances,
// this also implicitly frees all associated memory, but for
// heap-allocated instances, you must still call g_variant_dict_unref()
// afterwards.
//
// You will typically want to use a heap-allocated #GVariantDict when
// you expose it as part of an API.  For most other uses, the
// stack-allocated form will be more convenient.
//
// Consider the following two examples that do the same thing in each
// style: take an existing dictionary and look up the "count" uint32
// key, adding 1 to it if it is found, or returning an error if the
// key is not found.  Each returns the new dictionary as a floating
// #GVariant.
//
// ## Using a stack-allocated GVariantDict
//
// |[&lt;!-- language="C" --&gt;
//
//	GVariant *
//	add_to_count (GVariant  *orig,
//	              GError   **error)
//	{
//	  GVariantDict dict;
//	  guint32 count;
//
//	  g_variant_dict_init (&amp;dict, orig);
//	  if (!g_variant_dict_lookup (&amp;dict, "count", "u", &amp;count))
//	    {
//	      g_set_error (...);
//	      g_variant_dict_clear (&amp;dict);
//	      return NULL;
//	    }
//
//	  g_variant_dict_insert (&amp;dict, "count", "u", count + 1);
//
//	  return g_variant_dict_end (&amp;dict);
//	}
//
// ]|
//
// ## Using heap-allocated GVariantDict
//
// |[&lt;!-- language="C" --&gt;
//
//	GVariant *
//	add_to_count (GVariant  *orig,
//	              GError   **error)
//	{
//	  GVariantDict *dict;
//	  GVariant *result;
//	  guint32 count;
//
//	  dict = g_variant_dict_new (orig);
//
//	  if (g_variant_dict_lookup (dict, "count", "u", &amp;count))
//	    {
//	      g_variant_dict_insert (dict, "count", "u", count + 1);
//	      result = g_variant_dict_end (dict);
//	    }
//	  else
//	    {
//	      g_set_error (...);
//	      result = NULL;
//	    }
//
//	  g_variant_dict_unref (dict);
//
//	  return result;
//	}
//
// ]|
type VariantDict struct {
}

// #GVariantIter is an opaque data structure and can only be accessed
// using the following functions.
type VariantIter struct {
	X uintptr
}

// The range of possible top-level types of #GVariant instances.
type VariantClass int

const (

	// The #GVariant is a boolean.
	GVariantClassBooleanValue VariantClass = 98
	// The #GVariant is a byte.
	GVariantClassByteValue VariantClass = 121
	// The #GVariant is a signed 16 bit integer.
	GVariantClassInt16Value VariantClass = 110
	// The #GVariant is an unsigned 16 bit integer.
	GVariantClassUint16Value VariantClass = 113
	// The #GVariant is a signed 32 bit integer.
	GVariantClassInt32Value VariantClass = 105
	// The #GVariant is an unsigned 32 bit integer.
	GVariantClassUint32Value VariantClass = 117
	// The #GVariant is a signed 64 bit integer.
	GVariantClassInt64Value VariantClass = 120
	// The #GVariant is an unsigned 64 bit integer.
	GVariantClassUint64Value VariantClass = 116
	// The #GVariant is a file handle index.
	GVariantClassHandleValue VariantClass = 104
	// The #GVariant is a double precision floating
	//                          point value.
	GVariantClassDoubleValue VariantClass = 100
	// The #GVariant is a normal string.
	GVariantClassStringValue VariantClass = 115
	// The #GVariant is a D-Bus object path
	//                               string.
	GVariantClassObjectPathValue VariantClass = 111
	// The #GVariant is a D-Bus signature string.
	GVariantClassSignatureValue VariantClass = 103
	// The #GVariant is a variant.
	GVariantClassVariantValue VariantClass = 118
	// The #GVariant is a maybe-typed value.
	GVariantClassMaybeValue VariantClass = 109
	// The #GVariant is an array.
	GVariantClassArrayValue VariantClass = 97
	// The #GVariant is a tuple.
	GVariantClassTupleValue VariantClass = 40
	// The #GVariant is a dictionary entry.
	GVariantClassDictEntryValue VariantClass = 123
)

// Error codes returned by parsing text-format GVariants.
type VariantParseError int

const (

	// generic error (unused)
	GVariantParseErrorFailedValue VariantParseError = 0
	// a non-basic #GVariantType was given where a basic type was expected
	GVariantParseErrorBasicTypeExpectedValue VariantParseError = 1
	// cannot infer the #GVariantType
	GVariantParseErrorCannotInferTypeValue VariantParseError = 2
	// an indefinite #GVariantType was given where a definite type was expected
	GVariantParseErrorDefiniteTypeExpectedValue VariantParseError = 3
	// extra data after parsing finished
	GVariantParseErrorInputNotAtEndValue VariantParseError = 4
	// invalid character in number or unicode escape
	GVariantParseErrorInvalidCharacterValue VariantParseError = 5
	// not a valid #GVariant format string
	GVariantParseErrorInvalidFormatStringValue VariantParseError = 6
	// not a valid object path
	GVariantParseErrorInvalidObjectPathValue VariantParseError = 7
	// not a valid type signature
	GVariantParseErrorInvalidSignatureValue VariantParseError = 8
	// not a valid #GVariant type string
	GVariantParseErrorInvalidTypeStringValue VariantParseError = 9
	// could not find a common type for array entries
	GVariantParseErrorNoCommonTypeValue VariantParseError = 10
	// the numerical value is out of range of the given type
	GVariantParseErrorNumberOutOfRangeValue VariantParseError = 11
	// the numerical value is out of range for any type
	GVariantParseErrorNumberTooBigValue VariantParseError = 12
	// cannot parse as variant of the specified type
	GVariantParseErrorTypeErrorValue VariantParseError = 13
	// an unexpected token was encountered
	GVariantParseErrorUnexpectedTokenValue VariantParseError = 14
	// an unknown keyword was encountered
	GVariantParseErrorUnknownKeywordValue VariantParseError = 15
	// unterminated string constant
	GVariantParseErrorUnterminatedStringConstantValue VariantParseError = 16
	// no value given
	GVariantParseErrorValueExpectedValue VariantParseError = 17
	// variant was too deeply nested; #GVariant is only guaranteed to handle nesting up to 64 levels (Since: 2.64)
	GVariantParseErrorRecursionValue VariantParseError = 18
)

var xVariantIsObjectPath func(string) bool

// Determines if a given string is a valid D-Bus object path.  You
// should ensure that a string is a valid D-Bus object path before
// passing it to g_variant_new_object_path().
//
// A valid object path starts with `/` followed by zero or more
// sequences of characters separated by `/` characters.  Each sequence
// must contain only the characters `[A-Z][a-z][0-9]_`.  No sequence
// (including the one following the final `/` character) may be empty.
func VariantIsObjectPath(StringVar string) bool {

	cret := xVariantIsObjectPath(StringVar)
	return cret
}

var xVariantIsSignature func(string) bool

// Determines if a given string is a valid D-Bus type signature.  You
// should ensure that a string is a valid D-Bus type signature before
// passing it to g_variant_new_signature().
//
// D-Bus type signatures consist of zero or more definite #GVariantType
// strings in sequence.
func VariantIsSignature(StringVar string) bool {

	cret := xVariantIsSignature(StringVar)
	return cret
}

var xVariantParse func(*VariantType, string, string, string, **Error) *Variant

// Parses a #GVariant from a text representation.
//
// A single #GVariant is parsed from the content of @text.
//
// The format is described [here][gvariant-text].
//
// The memory at @limit will never be accessed and the parser behaves as
// if the character at @limit is the nul terminator.  This has the
// effect of bounding @text.
//
// If @endptr is non-%NULL then @text is permitted to contain data
// following the value that this function parses and @endptr will be
// updated to point to the first character past the end of the text
// parsed by this function.  If @endptr is %NULL and there is extra data
// then an error is returned.
//
// If @type is non-%NULL then the value will be parsed to have that
// type.  This may result in additional parse errors (in the case that
// the parsed value doesn't fit the type) but may also result in fewer
// errors (in the case that the type would have been ambiguous, such as
// with empty arrays).
//
// In the event that the parsing is successful, the resulting #GVariant
// is returned. It is never floating, and must be freed with
// g_variant_unref().
//
// In case of any error, %NULL will be returned.  If @error is non-%NULL
// then it will be set to reflect the error that occurred.
//
// Officially, the language understood by the parser is "any string
// produced by g_variant_print()".
//
// There may be implementation specific restrictions on deeply nested values,
// which would result in a %G_VARIANT_PARSE_ERROR_RECURSION error. #GVariant is
// guaranteed to handle nesting up to at least 64 levels.
func VariantParse(TypeVar *VariantType, TextVar string, LimitVar string, EndptrVar string) (*Variant, error) {
	var cerr *Error

	cret := xVariantParse(TypeVar, TextVar, LimitVar, EndptrVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xVariantParseErrorPrintContext func(*Error, string) string

// Pretty-prints a message showing the context of a #GVariant parse
// error within the string for which parsing was attempted.
//
// The resulting string is suitable for output to the console or other
// monospace media where newlines are treated in the usual way.
//
// The message will typically look something like one of the following:
//
// |[
// unterminated string constant:
//
//	(1, 2, 3, 'abc
//	          ^^^^
//
// ]|
//
// or
//
// |[
// unable to find a common type:
//
//	[1, 2, 3, 'str']
//	 ^        ^^^^^
//
// ]|
//
// The format of the message may change in a future version.
//
// @error must have come from a failed attempt to g_variant_parse() and
// @source_str must be exactly the same string that caused the error.
// If @source_str was not nul-terminated when you passed it to
// g_variant_parse() then you must add nul termination before using this
// function.
func VariantParseErrorPrintContext(ErrorVar *Error, SourceStrVar string) string {

	cret := xVariantParseErrorPrintContext(ErrorVar, SourceStrVar)
	return cret
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GLIB"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}
	core.PuregoSafeRegister(&xVariantIsObjectPath, lib, "g_variant_is_object_path")
	core.PuregoSafeRegister(&xVariantIsSignature, lib, "g_variant_is_signature")
	core.PuregoSafeRegister(&xVariantParse, lib, "g_variant_parse")
	core.PuregoSafeRegister(&xVariantParseErrorPrintContext, lib, "g_variant_parse_error_print_context")

}
