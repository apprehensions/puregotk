// Package glib was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package glib

import (
	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
)

// Contains the public fields of a GArray.
type Array struct {
	Data uintptr

	Len uint
}

// Contains the public fields of a GByteArray.
type ByteArray struct {
	Data byte

	Len uint
}

// A simple refcounted data type representing an immutable sequence of zero or
// more bytes from an unspecified origin.
//
// The purpose of a #GBytes is to keep the memory region that it holds
// alive for as long as anyone holds a reference to the bytes.  When
// the last reference count is dropped, the memory is released. Multiple
// unrelated callers can use byte data in the #GBytes without coordinating
// their activities, resting assured that the byte data will not change or
// move while they hold a reference.
//
// A #GBytes can come from many different origins that may have
// different procedures for freeing the memory region.  Examples are
// memory from g_malloc(), from memory slices, from a #GMappedFile or
// memory from other allocators.
//
// #GBytes work well as keys in #GHashTable. Use g_bytes_equal() and
// g_bytes_hash() as parameters to g_hash_table_new() or g_hash_table_new_full().
// #GBytes can also be used as keys in a #GTree by passing the g_bytes_compare()
// function to g_tree_new().
//
// The data pointed to by this bytes must not be modified. For a mutable
// array of bytes see #GByteArray. Use g_bytes_unref_to_array() to create a
// mutable array for a #GBytes sequence. To create an immutable #GBytes from
// a mutable #GByteArray, use the g_byte_array_free_to_bytes() function.
type Bytes struct {
}

// Contains the public fields of a pointer array.
type PtrArray struct {
	Pdata uintptr

	Len uint
}

var xByteArrayFree func(uintptr, bool) byte

// Frees the memory allocated by the #GByteArray. If @free_segment is
// %TRUE it frees the actual byte data. If the reference count of
// @array is greater than one, the #GByteArray wrapper is preserved but
// the size of @array will be set to zero.
func ByteArrayFree(ArrayVar uintptr, FreeSegmentVar bool) byte {

	cret := xByteArrayFree(ArrayVar, FreeSegmentVar)
	return cret
}

var xByteArrayFreeToBytes func(uintptr) *Bytes

// Transfers the data from the #GByteArray into a new immutable #GBytes.
//
// The #GByteArray is freed unless the reference count of @array is greater
// than one, the #GByteArray wrapper is preserved but the size of @array
// will be set to zero.
//
// This is identical to using g_bytes_new_take() and g_byte_array_free()
// together.
func ByteArrayFreeToBytes(ArrayVar uintptr) *Bytes {

	cret := xByteArrayFreeToBytes(ArrayVar)
	return cret
}

var xByteArrayNew func() uintptr

// Creates a new #GByteArray with a reference count of 1.
func ByteArrayNew() uintptr {

	cret := xByteArrayNew()
	return cret
}

var xByteArrayNewTake func(uintptr, uint) uintptr

// Create byte array containing the data. The data will be owned by the array
// and will be freed with g_free(), i.e. it could be allocated using g_strdup().
//
// Do not use it if @len is greater than %G_MAXUINT. #GByteArray
// stores the length of its data in #guint, which may be shorter than
// #gsize.
func ByteArrayNewTake(DataVar uintptr, LenVar uint) uintptr {

	cret := xByteArrayNewTake(DataVar, LenVar)
	return cret
}

var xByteArraySteal func(uintptr, uint) byte

// Frees the data in the array and resets the size to zero, while
// the underlying array is preserved for use elsewhere and returned
// to the caller.
func ByteArraySteal(ArrayVar uintptr, LenVar uint) byte {

	cret := xByteArraySteal(ArrayVar, LenVar)
	return cret
}

var xByteArrayUnref func(uintptr)

// Atomically decrements the reference count of @array by one. If the
// reference count drops to 0, all memory allocated by the array is
// released. This function is thread-safe and may be called from any
// thread.
func ByteArrayUnref(ArrayVar uintptr) {

	xByteArrayUnref(ArrayVar)

}

var xPtrArrayFind func(uintptr, uintptr, uint) bool

// Checks whether @needle exists in @haystack. If the element is found, %TRUE is
// returned and the element’s index is returned in @index_ (if non-%NULL).
// Otherwise, %FALSE is returned and @index_ is undefined. If @needle exists
// multiple times in @haystack, the index of the first instance is returned.
//
// This does pointer comparisons only. If you want to use more complex equality
// checks, such as string comparisons, use g_ptr_array_find_with_equal_func().
func PtrArrayFind(HaystackVar uintptr, NeedleVar uintptr, IndexVar uint) bool {

	cret := xPtrArrayFind(HaystackVar, NeedleVar, IndexVar)
	return cret
}

var xPtrArrayFindWithEqualFunc func(uintptr, uintptr, uintptr, uint) bool

// Checks whether @needle exists in @haystack, using the given @equal_func.
// If the element is found, %TRUE is returned and the element’s index is
// returned in @index_ (if non-%NULL). Otherwise, %FALSE is returned and @index_
// is undefined. If @needle exists multiple times in @haystack, the index of
// the first instance is returned.
//
// @equal_func is called with the element from the array as its first parameter,
// and @needle as its second parameter. If @equal_func is %NULL, pointer
// equality is used.
func PtrArrayFindWithEqualFunc(HaystackVar uintptr, NeedleVar uintptr, EqualFuncVar EqualFunc, IndexVar uint) bool {

	cret := xPtrArrayFindWithEqualFunc(HaystackVar, NeedleVar, purego.NewCallback(EqualFuncVar), IndexVar)
	return cret
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GLIB"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}
	core.PuregoSafeRegister(&xByteArrayFree, lib, "g_byte_array_free")
	core.PuregoSafeRegister(&xByteArrayFreeToBytes, lib, "g_byte_array_free_to_bytes")
	core.PuregoSafeRegister(&xByteArrayNew, lib, "g_byte_array_new")
	core.PuregoSafeRegister(&xByteArrayNewTake, lib, "g_byte_array_new_take")
	core.PuregoSafeRegister(&xByteArraySteal, lib, "g_byte_array_steal")
	core.PuregoSafeRegister(&xByteArrayUnref, lib, "g_byte_array_unref")
	core.PuregoSafeRegister(&xPtrArrayFind, lib, "g_ptr_array_find")
	core.PuregoSafeRegister(&xPtrArrayFindWithEqualFunc, lib, "g_ptr_array_find_with_equal_func")

}
