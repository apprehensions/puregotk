// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/gobject"
)

type NetworkAddressClass struct {
	ParentClass uintptr
}

type NetworkAddressPrivate struct {
}

// #GNetworkAddress provides an easy way to resolve a hostname and
// then attempt to connect to that host, handling the possibility of
// multiple IP addresses and multiple address families.
//
// The enumeration results of resolved addresses *may* be cached as long
// as this object is kept alive which may have unexpected results if
// alive for too long.
//
// See #GSocketConnectable for an example of using the connectable
// interface.
type NetworkAddress struct {
	gobject.Object
}

func NetworkAddressNewFromInternalPtr(ptr uintptr) *NetworkAddress {
	cls := &NetworkAddress{}
	cls.Ptr = ptr
	return cls
}

var xNewNetworkAddress func(string, uint16) uintptr

// Creates a new #GSocketConnectable for connecting to the given
// @hostname and @port.
//
// Note that depending on the configuration of the machine, a
// @hostname of `localhost` may refer to the IPv4 loopback address
// only, or to both IPv4 and IPv6; use
// g_network_address_new_loopback() to create a #GNetworkAddress that
// is guaranteed to resolve to both addresses.
func NewNetworkAddress(HostnameVar string, PortVar uint16) *NetworkAddress {
	NewNetworkAddressPtr := xNewNetworkAddress(HostnameVar, PortVar)
	if NewNetworkAddressPtr == 0 {
		return nil
	}

	NewNetworkAddressCls := &NetworkAddress{}
	NewNetworkAddressCls.Ptr = NewNetworkAddressPtr
	return NewNetworkAddressCls
}

var xNewLoopbackNetworkAddress func(uint16) uintptr

// Creates a new #GSocketConnectable for connecting to the local host
// over a loopback connection to the given @port. This is intended for
// use in connecting to local services which may be running on IPv4 or
// IPv6.
//
// The connectable will return IPv4 and IPv6 loopback addresses,
// regardless of how the host resolves `localhost`. By contrast,
// g_network_address_new() will often only return an IPv4 address when
// resolving `localhost`, and an IPv6 address for `localhost6`.
//
// g_network_address_get_hostname() will always return `localhost` for
// a #GNetworkAddress created with this constructor.
func NewLoopbackNetworkAddress(PortVar uint16) *NetworkAddress {
	NewLoopbackNetworkAddressPtr := xNewLoopbackNetworkAddress(PortVar)
	if NewLoopbackNetworkAddressPtr == 0 {
		return nil
	}

	NewLoopbackNetworkAddressCls := &NetworkAddress{}
	NewLoopbackNetworkAddressCls.Ptr = NewLoopbackNetworkAddressPtr
	return NewLoopbackNetworkAddressCls
}

var xNetworkAddressGetHostname func(uintptr) string

// Gets @addr's hostname. This might be either UTF-8 or ASCII-encoded,
// depending on what @addr was created with.
func (x *NetworkAddress) GetHostname() string {

	return xNetworkAddressGetHostname(x.GoPointer())

}

var xNetworkAddressGetPort func(uintptr) uint16

// Gets @addr's port number
func (x *NetworkAddress) GetPort() uint16 {

	return xNetworkAddressGetPort(x.GoPointer())

}

var xNetworkAddressGetScheme func(uintptr) string

// Gets @addr's scheme
func (x *NetworkAddress) GetScheme() string {

	return xNetworkAddressGetScheme(x.GoPointer())

}

func (c *NetworkAddress) GoPointer() uintptr {
	return c.Ptr
}

func (c *NetworkAddress) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Creates a #GSocketAddressEnumerator for @connectable.
func (x *NetworkAddress) Enumerate() *SocketAddressEnumerator {

	EnumeratePtr := XGSocketConnectableEnumerate(x.GoPointer())
	if EnumeratePtr == 0 {
		return nil
	}

	EnumerateCls := &SocketAddressEnumerator{}
	EnumerateCls.Ptr = EnumeratePtr
	return EnumerateCls

}

// Creates a #GSocketAddressEnumerator for @connectable that will
// return a #GProxyAddress for each of its addresses that you must connect
// to via a proxy.
//
// If @connectable does not implement
// g_socket_connectable_proxy_enumerate(), this will fall back to
// calling g_socket_connectable_enumerate().
func (x *NetworkAddress) ProxyEnumerate() *SocketAddressEnumerator {

	ProxyEnumeratePtr := XGSocketConnectableProxyEnumerate(x.GoPointer())
	if ProxyEnumeratePtr == 0 {
		return nil
	}

	ProxyEnumerateCls := &SocketAddressEnumerator{}
	ProxyEnumerateCls.Ptr = ProxyEnumeratePtr
	return ProxyEnumerateCls

}

// Format a #GSocketConnectable as a string. This is a human-readable format for
// use in debugging output, and is not a stable serialization format. It is not
// suitable for use in user interfaces as it exposes too much information for a
// user.
//
// If the #GSocketConnectable implementation does not support string formatting,
// the implementationâ€™s type name will be returned as a fallback.
func (x *NetworkAddress) ToString() string {

	return XGSocketConnectableToString(x.GoPointer())

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GIO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xNewNetworkAddress, lib, "g_network_address_new")
	core.PuregoSafeRegister(&xNewLoopbackNetworkAddress, lib, "g_network_address_new_loopback")

	core.PuregoSafeRegister(&xNetworkAddressGetHostname, lib, "g_network_address_get_hostname")
	core.PuregoSafeRegister(&xNetworkAddressGetPort, lib, "g_network_address_get_port")
	core.PuregoSafeRegister(&xNetworkAddressGetScheme, lib, "g_network_address_get_scheme")

}
