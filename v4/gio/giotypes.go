// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import "github.com/jwijenbergh/puregotk/v4/glib"

// Type definition for a function that will be called back when an asynchronous
// operation within GIO has been completed. #GAsyncReadyCallback
// callbacks from #GTask are guaranteed to be invoked in a later
// iteration of the
// [thread-default main context][g-main-context-push-thread-default]
// where the #GTask was created. All other users of
// #GAsyncReadyCallback must likewise call it asynchronously in a
// later iteration of the main context.
//
// The asynchronous operation is guaranteed to have held a reference to
// @source_object from the time when the `*_async()` function was called, until
// after this callback returns.
type AsyncReadyCallback func(uintptr, uintptr, uintptr)

// This is the function type of the callback used for the #GSource
// returned by g_cancellable_source_new().
type CancellableSourceFunc func(uintptr, uintptr) bool

// Function signature for a function used to determine the #GType to
// use for an interface proxy (if @interface_name is not %NULL) or
// object proxy (if @interface_name is %NULL).
//
// This function is called in the
// [thread-default main loop][g-main-context-push-thread-default]
// that @manager was constructed in.
type DBusProxyTypeFunc func(uintptr, string, string, uintptr) []interface{}

// This is the function type of the callback used for the #GSource
// returned by g_datagram_based_create_source().
type DatagramBasedSourceFunc func(uintptr, glib.IOCondition, uintptr) bool

// This callback type is used by g_file_measure_disk_usage() to make
// periodic progress reports when measuring the amount of disk spaced
// used by a directory.
//
// These calls are made on a best-effort basis and not all types of
// #GFile will support them.  At the minimum, however, one call will
// always be made immediately.
//
// In the case that there is no support, @reporting will be set to
// %FALSE (and the other values undefined) and no further calls will be
// made.  Otherwise, the @reporting will be %TRUE and the other values
// all-zeros during the first (immediate) call.  In this way, you can
// know which type of progress UI to show without a delay.
//
// For g_file_measure_disk_usage() the callback is made directly.  For
// g_file_measure_disk_usage_async() the callback is made via the
// default main context of the calling thread (ie: the same way that the
// final async result would be reported).
//
// @current_size is in the same units as requested by the operation (see
// %G_FILE_MEASURE_APPARENT_SIZE).
//
// The frequency of the updates is implementation defined, but is
// ideally about once every 200ms.
//
// The last progress callback may or may not be equal to the final
// result.  Always check the async result to get the final value.
type FileMeasureProgressCallback func(bool, uint64, uint64, uint64, uintptr)

// When doing file operations that may take a while, such as moving
// a file or copying a file, a progress callback is used to pass how
// far along that operation is to the application.
type FileProgressCallback func(int64, int64, uintptr)

// When loading the partial contents of a file with g_file_load_partial_contents_async(),
// it may become necessary to determine if any more data from the file should be loaded.
// A #GFileReadMoreCallback function facilitates this by returning %TRUE if more data
// should be read, or %FALSE otherwise.
type FileReadMoreCallback func(string, int64, uintptr) bool

// I/O Job function.
//
// Long-running jobs should periodically check the @cancellable
// to see if they have been cancelled.
type IOSchedulerJobFunc func(*IOSchedulerJob, uintptr, uintptr) bool

// This is the function type of the callback used for the #GSource
// returned by g_pollable_input_stream_create_source() and
// g_pollable_output_stream_create_source().
type PollableSourceFunc func(uintptr, uintptr) bool

// Simple thread function that runs an asynchronous operation and
// checks for cancellation.
type SimpleAsyncThreadFunc func(uintptr, uintptr, uintptr)

// This is the function type of the callback used for the #GSource
// returned by g_socket_create_source().
type SocketSourceFunc func(uintptr, glib.IOCondition, uintptr) bool

// Determines if a string matches a file attribute.
type FileAttributeMatcher struct {
}

// #GIOExtension is an opaque data structure and can only be accessed
// using the following functions.
type IOExtension struct {
}

// #GIOExtensionPoint is an opaque data structure and can only be accessed
// using the following functions.
type IOExtensionPoint struct {
}

// Opaque class for defining and scheduling IO jobs.
type IOSchedulerJob struct {
}

type IOStreamAdapter struct {
}

// Structure used for scatter/gather data input when receiving multiple
// messages or packets in one go. You generally pass in an array of empty
// #GInputVectors and the operation will use all the buffers as if they
// were one buffer, and will set @bytes_received to the total number of bytes
// received across all #GInputVectors.
//
// This structure closely mirrors `struct mmsghdr` and `struct msghdr` from
// the POSIX sockets API (see `man 2 recvmmsg`).
//
// If @address is non-%NULL then it is set to the source address the message
// was received from, and the caller must free it afterwards.
//
// If @control_messages is non-%NULL then it is set to an array of control
// messages received with the message (if any), and the caller must free it
// afterwards. @num_control_messages is set to the number of elements in
// this array, which may be zero.
//
// Flags relevant to this message will be returned in @flags. For example,
// `MSG_EOR` or `MSG_TRUNC`.
type InputMessage struct {
	Address **SocketAddress

	Vectors uintptr

	NumVectors uint

	BytesReceived uint

	Flags int32

	ControlMessages uintptr

	NumControlMessages uint
}

// Structure used for scatter/gather data input.
// You generally pass in an array of #GInputVectors
// and the operation will store the read data starting in the
// first buffer, switching to the next as needed.
type InputVector struct {
	Buffer uintptr

	Size uint
}

// Structure used for scatter/gather data output when sending multiple
// messages or packets in one go. You generally pass in an array of
// #GOutputVectors and the operation will use all the buffers as if they
// were one buffer.
//
// If @address is %NULL then the message is sent to the default receiver
// (as previously set by g_socket_connect()).
type OutputMessage struct {
	Address *SocketAddress

	Vectors *OutputVector

	NumVectors uint

	BytesSent uint

	ControlMessages uintptr

	NumControlMessages uint
}

// Structure used for scatter/gather data output.
// You generally pass in an array of #GOutputVectors
// and the operation will use all the buffers as if they were
// one buffer.
type OutputVector struct {
	Buffer uintptr

	Size uint
}

// Applications and libraries often contain binary or textual data that is
// really part of the application, rather than user data. For instance
// #GtkBuilder .ui files, splashscreen images, GMenu markup XML, CSS files,
// icons, etc. These are often shipped as files in `$datadir/appname`, or
// manually included as literal strings in the code.
//
// The #GResource API and the [glib-compile-resources][glib-compile-resources] program
// provide a convenient and efficient alternative to this which has some nice properties. You
// maintain the files as normal files, so its easy to edit them, but during the build the files
// are combined into a binary bundle that is linked into the executable. This means that loading
// the resource files are efficient (as they are already in memory, shared with other instances) and
// simple (no need to check for things like I/O errors or locate the files in the filesystem). It
// also makes it easier to create relocatable applications.
//
// Resource files can also be marked as compressed. Such files will be included in the resource bundle
// in a compressed form, but will be automatically uncompressed when the resource is used. This
// is very useful e.g. for larger text files that are parsed once (or rarely) and then thrown away.
//
// Resource files can also be marked to be preprocessed, by setting the value of the
// `preprocess` attribute to a comma-separated list of preprocessing options.
// The only options currently supported are:
//
// `xml-stripblanks` which will use the xmllint command
// to strip ignorable whitespace from the XML file. For this to work,
// the `XMLLINT` environment variable must be set to the full path to
// the xmllint executable, or xmllint must be in the `PATH`; otherwise
// the preprocessing step is skipped.
//
// `to-pixdata` (deprecated since gdk-pixbuf 2.32) which will use the
// `gdk-pixbuf-pixdata` command to convert images to the #GdkPixdata format,
// which allows you to create pixbufs directly using the data inside the
// resource file, rather than an (uncompressed) copy of it. For this, the
// `gdk-pixbuf-pixdata` program must be in the `PATH`, or the
// `GDK_PIXBUF_PIXDATA` environment variable must be set to the full path to the
// `gdk-pixbuf-pixdata` executable; otherwise the resource compiler will abort.
// `to-pixdata` has been deprecated since gdk-pixbuf 2.32, as #GResource
// supports embedding modern image formats just as well. Instead of using it,
// embed a PNG or SVG file in your #GResource.
//
// `json-stripblanks` which will use the `json-glib-format` command to strip
// ignorable whitespace from the JSON file. For this to work, the
// `JSON_GLIB_FORMAT` environment variable must be set to the full path to the
// `json-glib-format` executable, or it must be in the `PATH`;
// otherwise the preprocessing step is skipped. In addition, at least version
// 1.6 of `json-glib-format` is required.
//
// Resource files will be exported in the GResource namespace using the
// combination of the given `prefix` and the filename from the `file` element.
// The `alias` attribute can be used to alter the filename to expose them at a
// different location in the resource namespace. Typically, this is used to
// include files from a different source directory without exposing the source
// directory in the resource namespace, as in the example below.
//
// Resource bundles are created by the [glib-compile-resources][glib-compile-resources] program
// which takes an XML file that describes the bundle, and a set of files that the XML references. These
// are combined into a binary resource bundle.
//
// An example resource description:
// |[
// &lt;?xml version="1.0" encoding="UTF-8"?&gt;
// &lt;gresources&gt;
//
//	&lt;gresource prefix="/org/gtk/Example"&gt;
//	  &lt;file&gt;data/splashscreen.png&lt;/file&gt;
//	  &lt;file compressed="true"&gt;dialog.ui&lt;/file&gt;
//	  &lt;file preprocess="xml-stripblanks"&gt;menumarkup.xml&lt;/file&gt;
//	  &lt;file alias="example.css"&gt;data/example.css&lt;/file&gt;
//	&lt;/gresource&gt;
//
// &lt;/gresources&gt;
// ]|
//
// This will create a resource bundle with the following files:
// |[
// /org/gtk/Example/data/splashscreen.png
// /org/gtk/Example/dialog.ui
// /org/gtk/Example/menumarkup.xml
// /org/gtk/Example/example.css
// ]|
//
// Note that all resources in the process share the same namespace, so use Java-style
// path prefixes (like in the above example) to avoid conflicts.
//
// You can then use [glib-compile-resources][glib-compile-resources] to compile the XML to a
// binary bundle that you can load with g_resource_load(). However, its more common to use the --generate-source and
// --generate-header arguments to create a source file and header to link directly into your application.
// This will generate `get_resource()`, `register_resource()` and
// `unregister_resource()` functions, prefixed by the `--c-name` argument passed
// to [glib-compile-resources][glib-compile-resources]. `get_resource()` returns
// the generated #GResource object. The register and unregister functions
// register the resource so its files can be accessed using
// g_resources_lookup_data().
//
// Once a #GResource has been created and registered all the data in it can be accessed globally in the process by
// using API calls like g_resources_open_stream() to stream the data or g_resources_lookup_data() to get a direct pointer
// to the data. You can also use URIs like "resource:///org/gtk/Example/data/splashscreen.png" with #GFile to access
// the resource data.
//
// Some higher-level APIs, such as #GtkApplication, will automatically load
// resources from certain well-known paths in the resource namespace as a
// convenience. See the documentation for those APIs for details.
//
// There are two forms of the generated source, the default version uses the compiler support for constructor
// and destructor functions (where available) to automatically create and register the #GResource on startup
// or library load time. If you pass `--manual-register`, two functions to register/unregister the resource are created
// instead. This requires an explicit initialization call in your application/library, but it works on all platforms,
// even on the minor ones where constructors are not supported. (Constructor support is available for at least Win32, Mac OS and Linux.)
//
// Note that resource data can point directly into the data segment of e.g. a library, so if you are unloading libraries
// during runtime you need to be very careful with keeping around pointers to data from a resource, as this goes away
// when the library is unloaded. However, in practice this is not generally a problem, since most resource accesses
// are for your own resources, and resource data is often used once, during parsing, and then released.
//
// When debugging a program or testing a change to an installed version, it is often useful to be able to
// replace resources in the program or library, without recompiling, for debugging or quick hacking and testing
// purposes. Since GLib 2.50, it is possible to use the `G_RESOURCE_OVERLAYS` environment variable to selectively overlay
// resources with replacements from the filesystem.  It is a %G_SEARCHPATH_SEPARATOR-separated list of substitutions to perform
// during resource lookups. It is ignored when running in a setuid process.
//
// # A substitution has the form
//
// |[
//
//	/org/gtk/libgtk=/home/desrt/gtk-overlay
//
// ]|
//
// The part before the `=` is the resource subpath for which the overlay applies.  The part after is a
// filesystem path which contains files and subdirectories as you would like to be loaded as resources with the
// equivalent names.
//
// In the example above, if an application tried to load a resource with the resource path
// `/org/gtk/libgtk/ui/gtkdialog.ui` then GResource would check the filesystem path
// `/home/desrt/gtk-overlay/ui/gtkdialog.ui`.  If a file was found there, it would be used instead.  This is an
// overlay, not an outright replacement, which means that if a file is not found at that path, the built-in
// version will be used instead.  Whiteouts are not currently supported.
//
// Substitutions must start with a slash, and must not contain a trailing slash before the '='.  The path after
// the slash should ideally be absolute, but this is not strictly required.  It is possible to overlay the
// location of a single resource with an individual file.
type Resource struct {
}

// SRV (service) records are used by some network protocols to provide
// service-specific aliasing and load-balancing. For example, XMPP
// (Jabber) uses SRV records to locate the XMPP server for a domain;
// rather than connecting directly to "example.com" or assuming a
// specific server hostname like "xmpp.example.com", an XMPP client
// would look up the "xmpp-client" SRV record for "example.com", and
// then connect to whatever host was pointed to by that record.
//
// You can use g_resolver_lookup_service() or
// g_resolver_lookup_service_async() to find the #GSrvTargets
// for a given service. However, if you are simply planning to connect
// to the remote service, you can use #GNetworkService's
// #GSocketConnectable interface and not need to worry about
// #GSrvTarget at all.
type SrvTarget struct {
}
