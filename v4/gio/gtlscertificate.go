// Package gio was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gio

import (
	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
)

type TlsCertificateClass struct {
	ParentClass uintptr

	Padding uintptr
}

type TlsCertificatePrivate struct {
}

// A certificate used for TLS authentication and encryption.
// This can represent either a certificate only (eg, the certificate
// received by a client from a server), or the combination of
// a certificate and a private key (which is needed when acting as a
// #GTlsServerConnection).
type TlsCertificate struct {
	gobject.Object
}

func TlsCertificateNewFromInternalPtr(ptr uintptr) *TlsCertificate {
	cls := &TlsCertificate{}
	cls.Ptr = ptr
	return cls
}

var xNewFromFileTlsCertificate func(string) uintptr

// Creates a #GTlsCertificate from the data in @file.
//
// As of 2.72, if the filename ends in `.p12` or `.pfx` the data is loaded by
// g_tls_certificate_new_from_pkcs12() otherwise it is loaded by
// g_tls_certificate_new_from_pem(). See those functions for
// exact details.
//
// If @file cannot be read or parsed, the function will return %NULL and
// set @error.
func NewFromFileTlsCertificate(FileVar string) *TlsCertificate {
	NewFromFileTlsCertificatePtr := xNewFromFileTlsCertificate(FileVar)
	if NewFromFileTlsCertificatePtr == 0 {
		return nil
	}

	NewFromFileTlsCertificateCls := &TlsCertificate{}
	NewFromFileTlsCertificateCls.Ptr = NewFromFileTlsCertificatePtr
	return NewFromFileTlsCertificateCls
}

var xNewFromFileWithPasswordTlsCertificate func(string, string) uintptr

// Creates a #GTlsCertificate from the data in @file.
//
// If @file cannot be read or parsed, the function will return %NULL and
// set @error.
//
// Any unknown file types will error with %G_IO_ERROR_NOT_SUPPORTED.
// Currently only `.p12` and `.pfx` files are supported.
// See g_tls_certificate_new_from_pkcs12() for more details.
func NewFromFileWithPasswordTlsCertificate(FileVar string, PasswordVar string) *TlsCertificate {
	NewFromFileWithPasswordTlsCertificatePtr := xNewFromFileWithPasswordTlsCertificate(FileVar, PasswordVar)
	if NewFromFileWithPasswordTlsCertificatePtr == 0 {
		return nil
	}

	NewFromFileWithPasswordTlsCertificateCls := &TlsCertificate{}
	NewFromFileWithPasswordTlsCertificateCls.Ptr = NewFromFileWithPasswordTlsCertificatePtr
	return NewFromFileWithPasswordTlsCertificateCls
}

var xNewFromFilesTlsCertificate func(string, string) uintptr

// Creates a #GTlsCertificate from the PEM-encoded data in @cert_file
// and @key_file. The returned certificate will be the first certificate
// found in @cert_file. As of GLib 2.44, if @cert_file contains more
// certificates it will try to load a certificate chain. All
// certificates will be verified in the order found (top-level
// certificate should be the last one in the file) and the
// #GTlsCertificate:issuer property of each certificate will be set
// accordingly if the verification succeeds. If any certificate in the
// chain cannot be verified, the first certificate in the file will
// still be returned.
//
// If either file cannot be read or parsed, the function will return
// %NULL and set @error. Otherwise, this behaves like
// g_tls_certificate_new_from_pem().
func NewFromFilesTlsCertificate(CertFileVar string, KeyFileVar string) *TlsCertificate {
	NewFromFilesTlsCertificatePtr := xNewFromFilesTlsCertificate(CertFileVar, KeyFileVar)
	if NewFromFilesTlsCertificatePtr == 0 {
		return nil
	}

	NewFromFilesTlsCertificateCls := &TlsCertificate{}
	NewFromFilesTlsCertificateCls.Ptr = NewFromFilesTlsCertificatePtr
	return NewFromFilesTlsCertificateCls
}

var xNewFromPemTlsCertificate func(string, int) uintptr

// Creates a #GTlsCertificate from the PEM-encoded data in @data. If
// @data includes both a certificate and a private key, then the
// returned certificate will include the private key data as well. (See
// the #GTlsCertificate:private-key-pem property for information about
// supported formats.)
//
// The returned certificate will be the first certificate found in
// @data. As of GLib 2.44, if @data contains more certificates it will
// try to load a certificate chain. All certificates will be verified in
// the order found (top-level certificate should be the last one in the
// file) and the #GTlsCertificate:issuer property of each certificate
// will be set accordingly if the verification succeeds. If any
// certificate in the chain cannot be verified, the first certificate in
// the file will still be returned.
func NewFromPemTlsCertificate(DataVar string, LengthVar int) *TlsCertificate {
	NewFromPemTlsCertificatePtr := xNewFromPemTlsCertificate(DataVar, LengthVar)
	if NewFromPemTlsCertificatePtr == 0 {
		return nil
	}

	NewFromPemTlsCertificateCls := &TlsCertificate{}
	NewFromPemTlsCertificateCls.Ptr = NewFromPemTlsCertificatePtr
	return NewFromPemTlsCertificateCls
}

var xNewFromPkcs11UrisTlsCertificate func(string, string) uintptr

// Creates a #GTlsCertificate from a
// [PKCS \#11](https://docs.oasis-open.org/pkcs11/pkcs11-base/v3.0/os/pkcs11-base-v3.0-os.html) URI.
//
// An example @pkcs11_uri would be `pkcs11:model=Model;manufacturer=Manufacture;serial=1;token=My%20Client%20Certificate;id=%01`
//
// Where the tokenâ€™s layout is:
//
// |[
// Object 0:
//
//	URL: pkcs11:model=Model;manufacturer=Manufacture;serial=1;token=My%20Client%20Certificate;id=%01;object=private%20key;type=private
//	Type: Private key (RSA-2048)
//	ID: 01
//
// Object 1:
//
//	URL: pkcs11:model=Model;manufacturer=Manufacture;serial=1;token=My%20Client%20Certificate;id=%01;object=Certificate%20for%20Authentication;type=cert
//	Type: X.509 Certificate (RSA-2048)
//	ID: 01
//
// ]|
//
// In this case the certificate and private key would both be detected and used as expected.
// @pkcs_uri may also just reference an X.509 certificate object and then optionally
// @private_key_pkcs11_uri allows using a private key exposed under a different URI.
//
// Note that the private key is not accessed until usage and may fail or require a PIN later.
func NewFromPkcs11UrisTlsCertificate(Pkcs11UriVar string, PrivateKeyPkcs11UriVar string) *TlsCertificate {
	NewFromPkcs11UrisTlsCertificatePtr := xNewFromPkcs11UrisTlsCertificate(Pkcs11UriVar, PrivateKeyPkcs11UriVar)
	if NewFromPkcs11UrisTlsCertificatePtr == 0 {
		return nil
	}

	NewFromPkcs11UrisTlsCertificateCls := &TlsCertificate{}
	NewFromPkcs11UrisTlsCertificateCls.Ptr = NewFromPkcs11UrisTlsCertificatePtr
	return NewFromPkcs11UrisTlsCertificateCls
}

var xNewFromPkcs12TlsCertificate func(uintptr, uint, string) uintptr

// Creates a #GTlsCertificate from the data in @data. It must contain
// a certificate and matching private key.
//
// If extra certificates are included they will be verified as a chain
// and the #GTlsCertificate:issuer property will be set.
// All other data will be ignored.
//
// You can pass as single password for all of the data which will be
// used both for the PKCS #12 container as well as encrypted
// private keys. If decryption fails it will error with
// %G_TLS_ERROR_BAD_CERTIFICATE_PASSWORD.
//
// This constructor requires support in the current #GTlsBackend.
// If support is missing it will error with
// %G_IO_ERROR_NOT_SUPPORTED.
//
// Other parsing failures will error with %G_TLS_ERROR_BAD_CERTIFICATE.
func NewFromPkcs12TlsCertificate(DataVar uintptr, LengthVar uint, PasswordVar string) *TlsCertificate {
	NewFromPkcs12TlsCertificatePtr := xNewFromPkcs12TlsCertificate(DataVar, LengthVar, PasswordVar)
	if NewFromPkcs12TlsCertificatePtr == 0 {
		return nil
	}

	NewFromPkcs12TlsCertificateCls := &TlsCertificate{}
	NewFromPkcs12TlsCertificateCls.Ptr = NewFromPkcs12TlsCertificatePtr
	return NewFromPkcs12TlsCertificateCls
}

var xTlsCertificateGetDnsNames func(uintptr) uintptr

// Gets the value of #GTlsCertificate:dns-names.
func (x *TlsCertificate) GetDnsNames() uintptr {

	return xTlsCertificateGetDnsNames(x.GoPointer())

}

var xTlsCertificateGetIpAddresses func(uintptr) uintptr

// Gets the value of #GTlsCertificate:ip-addresses.
func (x *TlsCertificate) GetIpAddresses() uintptr {

	return xTlsCertificateGetIpAddresses(x.GoPointer())

}

var xTlsCertificateGetIssuer func(uintptr) uintptr

// Gets the #GTlsCertificate representing @cert's issuer, if known
func (x *TlsCertificate) GetIssuer() *TlsCertificate {

	GetIssuerPtr := xTlsCertificateGetIssuer(x.GoPointer())
	if GetIssuerPtr == 0 {
		return nil
	}

	gobject.IncreaseRef(GetIssuerPtr)

	GetIssuerCls := &TlsCertificate{}
	GetIssuerCls.Ptr = GetIssuerPtr
	return GetIssuerCls

}

var xTlsCertificateGetIssuerName func(uintptr) string

// Returns the issuer name from the certificate.
func (x *TlsCertificate) GetIssuerName() string {

	return xTlsCertificateGetIssuerName(x.GoPointer())

}

var xTlsCertificateGetNotValidAfter func(uintptr) *glib.DateTime

// Returns the time at which the certificate became or will become invalid.
func (x *TlsCertificate) GetNotValidAfter() *glib.DateTime {

	return xTlsCertificateGetNotValidAfter(x.GoPointer())

}

var xTlsCertificateGetNotValidBefore func(uintptr) *glib.DateTime

// Returns the time at which the certificate became or will become valid.
func (x *TlsCertificate) GetNotValidBefore() *glib.DateTime {

	return xTlsCertificateGetNotValidBefore(x.GoPointer())

}

var xTlsCertificateGetSubjectName func(uintptr) string

// Returns the subject name from the certificate.
func (x *TlsCertificate) GetSubjectName() string {

	return xTlsCertificateGetSubjectName(x.GoPointer())

}

var xTlsCertificateIsSame func(uintptr, uintptr) bool

// Check if two #GTlsCertificate objects represent the same certificate.
// The raw DER byte data of the two certificates are checked for equality.
// This has the effect that two certificates may compare equal even if
// their #GTlsCertificate:issuer, #GTlsCertificate:private-key, or
// #GTlsCertificate:private-key-pem properties differ.
func (x *TlsCertificate) IsSame(CertTwoVar *TlsCertificate) bool {

	return xTlsCertificateIsSame(x.GoPointer(), CertTwoVar.GoPointer())

}

var xTlsCertificateVerify func(uintptr, uintptr, uintptr) TlsCertificateFlags

// This verifies @cert and returns a set of #GTlsCertificateFlags
// indicating any problems found with it. This can be used to verify a
// certificate outside the context of making a connection, or to
// check a certificate against a CA that is not part of the system
// CA database.
//
// If @identity is not %NULL, @cert's name(s) will be compared against
// it, and %G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the return
// value if it does not match. If @identity is %NULL, that bit will
// never be set in the return value.
//
// If @trusted_ca is not %NULL, then @cert (or one of the certificates
// in its chain) must be signed by it, or else
// %G_TLS_CERTIFICATE_UNKNOWN_CA will be set in the return value. If
// @trusted_ca is %NULL, that bit will never be set in the return
// value.
//
// GLib guarantees that if certificate verification fails, at least one
// error will be set in the return value, but it does not guarantee
// that all possible errors will be set. Accordingly, you may not safely
// decide to ignore any particular type of error. For example, it would
// be incorrect to mask %G_TLS_CERTIFICATE_EXPIRED if you want to allow
// expired certificates, because this could potentially be the only
// error flag set even if other problems exist with the certificate.
//
// Because TLS session context is not used, #GTlsCertificate may not
// perform as many checks on the certificates as #GTlsConnection would.
// For example, certificate constraints may not be honored, and
// revocation checks may not be performed. The best way to verify TLS
// certificates used by a TLS connection is to let #GTlsConnection
// handle the verification.
func (x *TlsCertificate) Verify(IdentityVar SocketConnectable, TrustedCaVar *TlsCertificate) TlsCertificateFlags {

	return xTlsCertificateVerify(x.GoPointer(), IdentityVar.GoPointer(), TrustedCaVar.GoPointer())

}

func (c *TlsCertificate) GoPointer() uintptr {
	return c.Ptr
}

func (c *TlsCertificate) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GIO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xNewFromFileTlsCertificate, lib, "g_tls_certificate_new_from_file")
	core.PuregoSafeRegister(&xNewFromFileWithPasswordTlsCertificate, lib, "g_tls_certificate_new_from_file_with_password")
	core.PuregoSafeRegister(&xNewFromFilesTlsCertificate, lib, "g_tls_certificate_new_from_files")
	core.PuregoSafeRegister(&xNewFromPemTlsCertificate, lib, "g_tls_certificate_new_from_pem")
	core.PuregoSafeRegister(&xNewFromPkcs11UrisTlsCertificate, lib, "g_tls_certificate_new_from_pkcs11_uris")
	core.PuregoSafeRegister(&xNewFromPkcs12TlsCertificate, lib, "g_tls_certificate_new_from_pkcs12")

	core.PuregoSafeRegister(&xTlsCertificateGetDnsNames, lib, "g_tls_certificate_get_dns_names")
	core.PuregoSafeRegister(&xTlsCertificateGetIpAddresses, lib, "g_tls_certificate_get_ip_addresses")
	core.PuregoSafeRegister(&xTlsCertificateGetIssuer, lib, "g_tls_certificate_get_issuer")
	core.PuregoSafeRegister(&xTlsCertificateGetIssuerName, lib, "g_tls_certificate_get_issuer_name")
	core.PuregoSafeRegister(&xTlsCertificateGetNotValidAfter, lib, "g_tls_certificate_get_not_valid_after")
	core.PuregoSafeRegister(&xTlsCertificateGetNotValidBefore, lib, "g_tls_certificate_get_not_valid_before")
	core.PuregoSafeRegister(&xTlsCertificateGetSubjectName, lib, "g_tls_certificate_get_subject_name")
	core.PuregoSafeRegister(&xTlsCertificateIsSame, lib, "g_tls_certificate_is_same")
	core.PuregoSafeRegister(&xTlsCertificateVerify, lib, "g_tls_certificate_verify")

}
