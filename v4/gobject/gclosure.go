// Package gobject was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gobject

import (
	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
)

// The type used for callback functions in structure definitions and function
// signatures.
//
// This doesn't mean that all callback functions must take no  parameters and
// return void. The required signature of a callback function is determined by
// the context in which is used (e.g. the signal to which it is connected).
//
// Use G_CALLBACK() to cast the callback function to a #GCallback.
type Callback func()

// The type used for marshaller functions.
type ClosureMarshal func(*Closure, *Value, uint, uintptr, uintptr, uintptr)

// The type used for the various notification callbacks which can be registered
// on closures.
type ClosureNotify func(uintptr, *Closure)

// This is the signature of va_list marshaller functions, an optional
// marshaller that can be used in some situations to avoid
// marshalling the signal argument into GValues.
type VaClosureMarshal func(*Closure, *Value, *TypeInstance, []interface{}, uintptr, int32, uintptr)

// A #GCClosure is a specialization of #GClosure for C function callbacks.
type CClosure struct {
	Closure uintptr

	Callback uintptr
}

// A #GClosure represents a callback supplied by the programmer.
//
// It will generally comprise a function of some kind and a marshaller
// used to call it. It is the responsibility of the marshaller to
// convert the arguments for the invocation from #GValues into
// a suitable form, perform the callback on the converted arguments,
// and transform the return value back into a #GValue.
//
// In the case of C programs, a closure usually just holds a pointer
// to a function and maybe a data argument, and the marshaller
// converts between #GValue and native C types. The GObject
// library provides the #GCClosure type for this purpose. Bindings for
// other languages need marshallers which convert between #GValues
// and suitable representations in the runtime of the language in
// order to use functions written in that language as callbacks. Use
// g_closure_set_marshal() to set the marshaller on such a custom
// closure implementation.
//
// Within GObject, closures play an important role in the
// implementation of signals. When a signal is registered, the
// @c_marshaller argument to g_signal_new() specifies the default C
// marshaller for any closure which is connected to this
// signal. GObject provides a number of C marshallers for this
// purpose, see the g_cclosure_marshal_*() functions. Additional C
// marshallers can be generated with the [glib-genmarshal][glib-genmarshal]
// utility.  Closures can be explicitly connected to signals with
// g_signal_connect_closure(), but it usually more convenient to let
// GObject create a closure automatically by using one of the
// g_signal_connect_*() functions which take a callback function/user
// data pair.
//
// Using closures has a number of important advantages over a simple
// callback function/data pointer combination:
//
//   - Closures allow the callee to get the types of the callback parameters,
//     which means that language bindings don't have to write individual glue
//     for each callback type.
//
//   - The reference counting of #GClosure makes it easy to handle reentrancy
//     right; if a callback is removed while it is being invoked, the closure
//     and its parameters won't be freed until the invocation finishes.
//
//   - g_closure_invalidate() and invalidation notifiers allow callbacks to be
//     automatically removed when the objects they point to go away.
type Closure struct {
	RefCount uint

	MetaMarshalNouse uint

	NGuards uint

	NFnotifiers uint

	NInotifiers uint

	InInotify uint

	Floating uint

	DerivativeFlag uint

	InMarshal uint

	IsInvalid uint

	Data uintptr

	Notifiers *ClosureNotifyData
}

type ClosureNotifyData struct {
	Data uintptr

	Notify ClosureNotify
}

var xCclosureMarshalGeneric func(*Closure, *Value, uint, *Value, uintptr, uintptr)

// A generic marshaller function implemented via
// [libffi](http://sourceware.org/libffi/).
//
// Normally this function is not passed explicitly to g_signal_new(),
// but used automatically by GLib when specifying a %NULL marshaller.
func CclosureMarshalGeneric(ClosureVar *Closure, ReturnGvalueVar *Value, NParamValuesVar uint, ParamValuesVar *Value, InvocationHintVar uintptr, MarshalDataVar uintptr) {

	xCclosureMarshalGeneric(ClosureVar, ReturnGvalueVar, NParamValuesVar, ParamValuesVar, InvocationHintVar, MarshalDataVar)

}

var xCclosureNew func(uintptr, uintptr, uintptr) *Closure

// Creates a new closure which invokes @callback_func with @user_data as
// the last parameter.
//
// @destroy_data will be called as a finalize notifier on the #GClosure.
func CclosureNew(CallbackFuncVar Callback, UserDataVar uintptr, DestroyDataVar ClosureNotify) *Closure {

	return xCclosureNew(purego.NewCallback(CallbackFuncVar), UserDataVar, purego.NewCallback(DestroyDataVar))

}

var xCclosureNewSwap func(uintptr, uintptr, uintptr) *Closure

// Creates a new closure which invokes @callback_func with @user_data as
// the first parameter.
//
// @destroy_data will be called as a finalize notifier on the #GClosure.
func CclosureNewSwap(CallbackFuncVar Callback, UserDataVar uintptr, DestroyDataVar ClosureNotify) *Closure {

	return xCclosureNewSwap(purego.NewCallback(CallbackFuncVar), UserDataVar, purego.NewCallback(DestroyDataVar))

}

var xSignalTypeCclosureNew func([]interface{}, uint) *Closure

// Creates a new closure which invokes the function found at the offset
// @struct_offset in the class structure of the interface or classed type
// identified by @itype.
func SignalTypeCclosureNew(ItypeVar []interface{}, StructOffsetVar uint) *Closure {

	return xSignalTypeCclosureNew(ItypeVar, StructOffsetVar)

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GOBJECT"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}
	core.PuregoSafeRegister(&xCclosureMarshalGeneric, lib, "g_cclosure_marshal_generic")
	core.PuregoSafeRegister(&xCclosureNew, lib, "g_cclosure_new")
	core.PuregoSafeRegister(&xCclosureNewSwap, lib, "g_cclosure_new_swap")
	core.PuregoSafeRegister(&xSignalTypeCclosureNew, lib, "g_signal_type_cclosure_new")

}
