// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
)

// Prototype for shortcuts based on user callbacks.
type ShortcutFunc func(uintptr, *glib.Variant, uintptr) bool

type ActivateActionClass struct {
}

type CallbackActionClass struct {
}

type MnemonicActionClass struct {
}

type NamedActionClass struct {
}

type NothingActionClass struct {
}

type ShortcutActionClass struct {
}

type SignalActionClass struct {
}

// List of flags that can be passed to action activation.
//
// More flags may be added in the future.
type ShortcutActionFlags int

const (

	// The action is the only
	//   action that can be activated. If this flag is not set,
	//   a future activation may select a different action.
	ShortcutActionExclusiveValue ShortcutActionFlags = 1
)

// A `GtkShortcutAction` that calls gtk_widget_activate().
type ActivateAction struct {
	ShortcutAction
}

func ActivateActionNewFromInternalPtr(ptr uintptr) *ActivateAction {
	cls := &ActivateAction{}
	cls.Ptr = ptr
	return cls
}

func (c *ActivateAction) GoPointer() uintptr {
	return c.Ptr
}

func (c *ActivateAction) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// A `GtkShortcutAction` that invokes a callback.
type CallbackAction struct {
	ShortcutAction
}

func CallbackActionNewFromInternalPtr(ptr uintptr) *CallbackAction {
	cls := &CallbackAction{}
	cls.Ptr = ptr
	return cls
}

var xNewCallbackAction func(uintptr, uintptr, uintptr) uintptr

// Create a custom action that calls the given @callback when
// activated.
func NewCallbackAction(CallbackVar ShortcutFunc, DataVar uintptr, DestroyVar glib.DestroyNotify) *CallbackAction {
	var cls *CallbackAction

	cret := xNewCallbackAction(purego.NewCallback(CallbackVar), DataVar, purego.NewCallback(DestroyVar))

	if cret == 0 {
		return cls
	}
	cls = &CallbackAction{}
	cls.Ptr = cret
	return cls
}

func (c *CallbackAction) GoPointer() uintptr {
	return c.Ptr
}

func (c *CallbackAction) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// A `GtkShortcutAction` that calls gtk_widget_mnemonic_activate().
type MnemonicAction struct {
	ShortcutAction
}

func MnemonicActionNewFromInternalPtr(ptr uintptr) *MnemonicAction {
	cls := &MnemonicAction{}
	cls.Ptr = ptr
	return cls
}

func (c *MnemonicAction) GoPointer() uintptr {
	return c.Ptr
}

func (c *MnemonicAction) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// A `GtkShortcutAction` that activates an action by name.
type NamedAction struct {
	ShortcutAction
}

func NamedActionNewFromInternalPtr(ptr uintptr) *NamedAction {
	cls := &NamedAction{}
	cls.Ptr = ptr
	return cls
}

var xNewNamedAction func(string) uintptr

// Creates an action that when activated, activates
// the named action on the widget.
//
// It also passes the given arguments to it.
//
// See [method@Gtk.Widget.insert_action_group] for
// how to add actions to widgets.
func NewNamedAction(NameVar string) *NamedAction {
	var cls *NamedAction

	cret := xNewNamedAction(NameVar)

	if cret == 0 {
		return cls
	}
	cls = &NamedAction{}
	cls.Ptr = cret
	return cls
}

var xNamedActionGetActionName func(uintptr) string

// Returns the name of the action that will be activated.
func (x *NamedAction) GetActionName() string {

	cret := xNamedActionGetActionName(x.GoPointer())
	return cret
}

func (c *NamedAction) GoPointer() uintptr {
	return c.Ptr
}

func (c *NamedAction) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// A `GtkShortcutAction` that does nothing.
type NothingAction struct {
	ShortcutAction
}

func NothingActionNewFromInternalPtr(ptr uintptr) *NothingAction {
	cls := &NothingAction{}
	cls.Ptr = ptr
	return cls
}

func (c *NothingAction) GoPointer() uintptr {
	return c.Ptr
}

func (c *NothingAction) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// `GtkShortcutAction` encodes an action that can be triggered by a
// keyboard shortcut.
//
// `GtkShortcutActions` contain functions that allow easy presentation
// to end users as well as being printed for debugging.
//
// All `GtkShortcutActions` are immutable, you can only specify their
// properties during construction. If you want to change a action, you
// have to replace it with a new one. If you need to pass arguments to
// an action, these are specified by the higher-level `GtkShortcut` object.
//
// To activate a `GtkShortcutAction` manually, [method@Gtk.ShortcutAction.activate]
// can be called.
//
// GTK provides various actions:
//
//   - [class@Gtk.MnemonicAction]: a shortcut action that calls
//     gtk_widget_mnemonic_activate()
//   - [class@Gtk.CallbackAction]: a shortcut action that invokes
//     a given callback
//   - [class@Gtk.SignalAction]: a shortcut action that emits a
//     given signal
//   - [class@Gtk.ActivateAction]: a shortcut action that calls
//     gtk_widget_activate()
//   - [class@Gtk.NamedAction]: a shortcut action that calls
//     gtk_widget_activate_action()
//   - [class@Gtk.NothingAction]: a shortcut action that does nothing
type ShortcutAction struct {
	gobject.Object
}

func ShortcutActionNewFromInternalPtr(ptr uintptr) *ShortcutAction {
	cls := &ShortcutAction{}
	cls.Ptr = ptr
	return cls
}

var xParseStringShortcutAction func(string) uintptr

// Tries to parse the given string into an action.
//
// On success, the parsed action is returned. When parsing
// failed, %NULL is returned.
//
// The accepted strings are:
//
// - `nothing`, for `GtkNothingAction`
// - `activate`, for `GtkActivateAction`
// - `mnemonic-activate`, for `GtkMnemonicAction`
// - `action(NAME)`, for a `GtkNamedAction` for the action named `NAME`
// - `signal(NAME)`, for a `GtkSignalAction` for the signal `NAME`
func ParseStringShortcutAction(StringVar string) *ShortcutAction {
	var cls *ShortcutAction

	cret := xParseStringShortcutAction(StringVar)

	if cret == 0 {
		return cls
	}
	cls = &ShortcutAction{}
	cls.Ptr = cret
	return cls
}

var xShortcutActionActivate func(uintptr, ShortcutActionFlags, uintptr, *glib.Variant) bool

// Activates the action on the @widget with the given @args.
//
// Note that some actions ignore the passed in @flags, @widget or @args.
//
// Activation of an action can fail for various reasons. If the action
// is not supported by the @widget, if the @args don't match the action
// or if the activation otherwise had no effect, %FALSE will be returned.
func (x *ShortcutAction) Activate(FlagsVar ShortcutActionFlags, WidgetVar *Widget, ArgsVar *glib.Variant) bool {

	cret := xShortcutActionActivate(x.GoPointer(), FlagsVar, WidgetVar.GoPointer(), ArgsVar)
	return cret
}

var xShortcutActionPrint func(uintptr, *glib.String)

// Prints the given action into a string for the developer.
//
// This is meant for debugging and logging.
//
// The form of the representation may change at any time and is
// not guaranteed to stay identical.
func (x *ShortcutAction) Print(StringVar *glib.String) {

	xShortcutActionPrint(x.GoPointer(), StringVar)

}

var xShortcutActionToString func(uintptr) string

// Prints the given action into a human-readable string.
//
// This is a small wrapper around [method@Gtk.ShortcutAction.print]
// to help when debugging.
func (x *ShortcutAction) ToString() string {

	cret := xShortcutActionToString(x.GoPointer())
	return cret
}

func (c *ShortcutAction) GoPointer() uintptr {
	return c.Ptr
}

func (c *ShortcutAction) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// A `GtkShortcut`Action that emits a signal.
//
// Signals that are used in this way are referred to as keybinding signals,
// and they are expected to be defined with the %G_SIGNAL_ACTION flag.
type SignalAction struct {
	ShortcutAction
}

func SignalActionNewFromInternalPtr(ptr uintptr) *SignalAction {
	cls := &SignalAction{}
	cls.Ptr = ptr
	return cls
}

var xNewSignalAction func(string) uintptr

// Creates an action that when activated, emits the given action signal
// on the provided widget.
//
// It will also unpack the args into arguments passed to the signal.
func NewSignalAction(SignalNameVar string) *SignalAction {
	var cls *SignalAction

	cret := xNewSignalAction(SignalNameVar)

	if cret == 0 {
		return cls
	}
	cls = &SignalAction{}
	cls.Ptr = cret
	return cls
}

var xSignalActionGetSignalName func(uintptr) string

// Returns the name of the signal that will be emitted.
func (x *SignalAction) GetSignalName() string {

	cret := xSignalActionGetSignalName(x.GoPointer())
	return cret
}

func (c *SignalAction) GoPointer() uintptr {
	return c.Ptr
}

func (c *SignalAction) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GTK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xNewCallbackAction, lib, "gtk_callback_action_new")

	core.PuregoSafeRegister(&xNewNamedAction, lib, "gtk_named_action_new")

	core.PuregoSafeRegister(&xNamedActionGetActionName, lib, "gtk_named_action_get_action_name")

	core.PuregoSafeRegister(&xParseStringShortcutAction, lib, "gtk_shortcut_action_parse_string")

	core.PuregoSafeRegister(&xShortcutActionActivate, lib, "gtk_shortcut_action_activate")
	core.PuregoSafeRegister(&xShortcutActionPrint, lib, "gtk_shortcut_action_print")
	core.PuregoSafeRegister(&xShortcutActionToString, lib, "gtk_shortcut_action_to_string")

	core.PuregoSafeRegister(&xNewSignalAction, lib, "gtk_signal_action_new")

	core.PuregoSafeRegister(&xSignalActionGetSignalName, lib, "gtk_signal_action_get_signal_name")

}
