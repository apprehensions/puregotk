// Package gtk was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package gtk

import (
	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
)

// Meta-data to be passed to gtk_recent_manager_add_full() when
// registering a recently used resource.
type RecentData struct {
	DisplayName uintptr

	Description uintptr

	MimeType uintptr

	AppName uintptr

	AppExec uintptr

	Groups []string

	IsPrivate bool
}

// `GtkRecentInfo` contains the metadata associated with an item in the
// recently used files list.
type RecentInfo struct {
}

// `GtkRecentManagerClass` contains only private data.
type RecentManagerClass struct {
	ParentClass uintptr
}

type RecentManagerPrivate struct {
}

// Error codes for `GtkRecentManager` operations
type RecentManagerError int

const (

	// the URI specified does not exists in
	//   the recently used resources list.
	RecentManagerErrorNotFoundValue RecentManagerError = 0
	// the URI specified is not valid.
	RecentManagerErrorInvalidUriValue RecentManagerError = 1
	// the supplied string is not
	//   UTF-8 encoded.
	RecentManagerErrorInvalidEncodingValue RecentManagerError = 2
	// no application has registered
	//   the specified item.
	RecentManagerErrorNotRegisteredValue RecentManagerError = 3
	// failure while reading the recently used
	//   resources file.
	RecentManagerErrorReadValue RecentManagerError = 4
	// failure while writing the recently used
	//   resources file.
	RecentManagerErrorWriteValue RecentManagerError = 5
	// unspecified error.
	RecentManagerErrorUnknownValue RecentManagerError = 6
)

// `GtkRecentManager` manages and looks up recently used files.
//
// Each recently used file is identified by its URI, and has meta-data
// associated to it, like the names and command lines of the applications
// that have registered it, the number of time each application has
// registered the same file, the mime type of the file and whether
// the file should be displayed only by the applications that have
// registered it.
//
// The recently used files list is per user.
//
// `GtkRecentManager` acts like a database of all the recently
// used files. You can create new `GtkRecentManager` objects, but
// it is more efficient to use the default manager created by GTK.
//
// Adding a new recently used file is as simple as:
//
// ```c
// GtkRecentManager *manager;
//
// manager = gtk_recent_manager_get_default ();
// gtk_recent_manager_add_item (manager, file_uri);
// ```
//
// The `GtkRecentManager` will try to gather all the needed information
// from the file itself through GIO.
//
// Looking up the meta-data associated with a recently used file
// given its URI requires calling [method@Gtk.RecentManager.lookup_item]:
//
// ```c
// GtkRecentManager *manager;
// GtkRecentInfo *info;
// GError *error = NULL;
//
// manager = gtk_recent_manager_get_default ();
// info = gtk_recent_manager_lookup_item (manager, file_uri, &amp;error);
// if (error)
//
//	{
//	  g_warning ("Could not find the file: %s", error-&gt;message);
//	  g_error_free (error);
//	}
//
// else
//
//	{
//	  // Use the info object
//	  gtk_recent_info_unref (info);
//	}
//
// ```
//
// In order to retrieve the list of recently used files, you can use
// [method@Gtk.RecentManager.get_items], which returns a list of
// [struct@Gtk.RecentInfo].
//
// Note that the maximum age of the recently used files list is
// controllable through the [property@Gtk.Settings:gtk-recent-files-max-age]
// property.
type RecentManager struct {
	gobject.Object
}

func RecentManagerNewFromInternalPtr(ptr uintptr) *RecentManager {
	cls := &RecentManager{}
	cls.Ptr = ptr
	return cls
}

var xNewRecentManager func() uintptr

// Creates a new recent manager object.
//
// Recent manager objects are used to handle the list of recently used
// resources. A `GtkRecentManager` object monitors the recently used
// resources list, and emits the [signal@Gtk.RecentManager::changed]
// signal each time something inside the list changes.
//
// `GtkRecentManager` objects are expensive: be sure to create them
// only when needed. You should use [func@Gtk.RecentManager.get_default]
// instead.
func NewRecentManager() *RecentManager {
	var cls *RecentManager

	cret := xNewRecentManager()

	if cret == 0 {
		return cls
	}
	cls = &RecentManager{}
	cls.Ptr = cret
	return cls
}

var xRecentManagerAddFull func(uintptr, string, *RecentData) bool

// Adds a new resource, pointed by @uri, into the recently used
// resources list, using the metadata specified inside the
// `GtkRecentData` passed in @recent_data.
//
// The passed URI will be used to identify this resource inside the
// list.
//
// In order to register the new recently used resource, metadata about
// the resource must be passed as well as the URI; the metadata is
// stored in a `GtkRecentData`, which must contain the MIME
// type of the resource pointed by the URI; the name of the application
// that is registering the item, and a command line to be used when
// launching the item.
//
// Optionally, a `GtkRecentData` might contain a UTF-8 string
// to be used when viewing the item instead of the last component of
// the URI; a short description of the item; whether the item should
// be considered private - that is, should be displayed only by the
// applications that have registered it.
func (x *RecentManager) AddFull(UriVar string, RecentDataVar *RecentData) bool {

	cret := xRecentManagerAddFull(x.GoPointer(), UriVar, RecentDataVar)
	return cret
}

var xRecentManagerAddItem func(uintptr, string) bool

// Adds a new resource, pointed by @uri, into the recently used
// resources list.
//
// This function automatically retrieves some of the needed
// metadata and setting other metadata to common default values;
// it then feeds the data to [method@Gtk.RecentManager.add_full].
//
// See [method@Gtk.RecentManager.add_full] if you want to explicitly
// define the metadata for the resource pointed by @uri.
func (x *RecentManager) AddItem(UriVar string) bool {

	cret := xRecentManagerAddItem(x.GoPointer(), UriVar)
	return cret
}

var xRecentManagerGetItems func(uintptr) *glib.List

// Gets the list of recently used resources.
func (x *RecentManager) GetItems() *glib.List {

	cret := xRecentManagerGetItems(x.GoPointer())
	return cret
}

var xRecentManagerHasItem func(uintptr, string) bool

// Checks whether there is a recently used resource registered
// with @uri inside the recent manager.
func (x *RecentManager) HasItem(UriVar string) bool {

	cret := xRecentManagerHasItem(x.GoPointer(), UriVar)
	return cret
}

var xRecentManagerLookupItem func(uintptr, string, **glib.Error) *RecentInfo

// Searches for a URI inside the recently used resources list, and
// returns a `GtkRecentInfo` containing information about the resource
// like its MIME type, or its display name.
func (x *RecentManager) LookupItem(UriVar string) (*RecentInfo, error) {
	var cerr *glib.Error

	cret := xRecentManagerLookupItem(x.GoPointer(), UriVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xRecentManagerMoveItem func(uintptr, string, string, **glib.Error) bool

// Changes the location of a recently used resource from @uri to @new_uri.
//
// Please note that this function will not affect the resource pointed
// by the URIs, but only the URI used in the recently used resources list.
func (x *RecentManager) MoveItem(UriVar string, NewUriVar string) (bool, error) {
	var cerr *glib.Error

	cret := xRecentManagerMoveItem(x.GoPointer(), UriVar, NewUriVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xRecentManagerPurgeItems func(uintptr) int

// Purges every item from the recently used resources list.
func (x *RecentManager) PurgeItems() (int, error) {
	var cerr *glib.Error

	cret := xRecentManagerPurgeItems(x.GoPointer())
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xRecentManagerRemoveItem func(uintptr, string, **glib.Error) bool

// Removes a resource pointed by @uri from the recently used resources
// list handled by a recent manager.
func (x *RecentManager) RemoveItem(UriVar string) (bool, error) {
	var cerr *glib.Error

	cret := xRecentManagerRemoveItem(x.GoPointer(), UriVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

func (c *RecentManager) GoPointer() uintptr {
	return c.Ptr
}

func (c *RecentManager) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Emitted when the current recently used resources manager changes
// its contents.
//
// This can happen either by calling [method@Gtk.RecentManager.add_item]
// or by another application.
func (x *RecentManager) ConnectChanged(cb func(RecentManager)) {
	fcb := func(clsPtr uintptr) {
		fa := RecentManager{}
		fa.Ptr = clsPtr

		cb(fa)

	}
	gobject.ObjectConnect(x.GoPointer(), "signal::changed", purego.NewCallback(fcb))
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("GTK"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xNewRecentManager, lib, "gtk_recent_manager_new")

	core.PuregoSafeRegister(&xRecentManagerAddFull, lib, "gtk_recent_manager_add_full")
	core.PuregoSafeRegister(&xRecentManagerAddItem, lib, "gtk_recent_manager_add_item")
	core.PuregoSafeRegister(&xRecentManagerGetItems, lib, "gtk_recent_manager_get_items")
	core.PuregoSafeRegister(&xRecentManagerHasItem, lib, "gtk_recent_manager_has_item")
	core.PuregoSafeRegister(&xRecentManagerLookupItem, lib, "gtk_recent_manager_lookup_item")
	core.PuregoSafeRegister(&xRecentManagerMoveItem, lib, "gtk_recent_manager_move_item")
	core.PuregoSafeRegister(&xRecentManagerPurgeItems, lib, "gtk_recent_manager_purge_items")
	core.PuregoSafeRegister(&xRecentManagerRemoveItem, lib, "gtk_recent_manager_remove_item")

}
