// Package pango was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package pango

import (
	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
)

// The `PangoGlyphGeometry` structure contains width and positioning
// information for a single glyph.
//
// Note that @width is not guaranteed to be the same as the glyph
// extents. Kerning and other positioning applied during shaping will
// affect both the @width and the @x_offset for the glyphs in the
// glyph string that results from shaping.
//
// The information in this struct is intended for rendering the glyphs,
// as follows:
//
// 1. Assume the current point is (x, y)
// 2. Render the current glyph at (x + x_offset, y + y_offset),
// 3. Advance the current point to (x + width, y)
// 4. Render the next glyph
type GlyphGeometry struct {
	Width GlyphUnit

	XOffset GlyphUnit

	YOffset GlyphUnit
}

// A `PangoGlyphInfo` structure represents a single glyph with
// positioning information and visual attributes.
type GlyphInfo struct {
	Glyph Glyph

	Geometry uintptr

	Attr uintptr
}

// A `PangoGlyphString` is used to store strings of glyphs with geometry
// and visual attribute information.
//
// The storage for the glyph information is owned by the structure
// which simplifies memory management.
type GlyphString struct {
	NumGlyphs int32

	Glyphs uintptr

	LogClusters int32

	Space int32
}

// A `PangoGlyphVisAttr` structure communicates information between
// the shaping and rendering phases.
//
// Currently, it contains cluster start and color information.
// More attributes may be added in the future.
//
// Clusters are stored in visual order, within the cluster, glyphs
// are always ordered in logical order, since visual order is meaningless;
// that is, in Arabic text, accent glyphs follow the glyphs for the
// base character.
type GlyphVisAttr struct {
	IsClusterStart uint

	IsColor uint
}

// The `PangoGlyphUnit` type is used to store dimensions within
// Pango.
//
// Dimensions are stored in 1/PANGO_SCALE of a device unit.
// (A device unit might be a pixel for screen display, or
// a point on a printer.) PANGO_SCALE is currently 1024, and
// may change in the future (unlikely though), but you should not
// depend on its exact value.
//
// The PANGO_PIXELS() macro can be used to convert from glyph units
// into device units with correct rounding.
type GlyphUnit = int32

// Flags influencing the shaping process.
//
// `PangoShapeFlags` can be passed to [func@Pango.shape_with_flags].
type ShapeFlags int

const (

	// Default value
	ShapeNoneValue ShapeFlags = 0
	// Round glyph positions and widths to whole device units
	//   This option should be set if the target renderer can't do subpixel positioning of glyphs
	ShapeRoundPositionsValue ShapeFlags = 1
)

var xShape func(string, int32, *Analysis, *GlyphString)

// Convert the characters in @text into glyphs.
//
// Given a segment of text and the corresponding `PangoAnalysis` structure
// returned from [func@Pango.itemize], convert the characters into glyphs. You
// may also pass in only a substring of the item from [func@Pango.itemize].
//
// It is recommended that you use [func@Pango.shape_full] instead, since
// that API allows for shaping interaction happening across text item
// boundaries.
//
// Note that the extra attributes in the @analyis that is returned from
// [func@Pango.itemize] have indices that are relative to the entire paragraph,
// so you need to subtract the item offset from their indices before
// calling [func@Pango.shape].
func Shape(TextVar string, LengthVar int32, AnalysisVar *Analysis, GlyphsVar *GlyphString) {

	xShape(TextVar, LengthVar, AnalysisVar, GlyphsVar)

}

var xShapeFull func(string, int32, string, int32, *Analysis, *GlyphString)

// Convert the characters in @text into glyphs.
//
// Given a segment of text and the corresponding `PangoAnalysis` structure
// returned from [func@Pango.itemize], convert the characters into glyphs.
// You may also pass in only a substring of the item from [func@Pango.itemize].
//
// This is similar to [func@Pango.shape], except it also can optionally take
// the full paragraph text as input, which will then be used to perform
// certain cross-item shaping interactions. If you have access to the broader
// text of which @item_text is part of, provide the broader text as
// @paragraph_text. If @paragraph_text is %NULL, item text is used instead.
//
// Note that the extra attributes in the @analyis that is returned from
// [func@Pango.itemize] have indices that are relative to the entire paragraph,
// so you do not pass the full paragraph text as @paragraph_text, you need
// to subtract the item offset from their indices before calling
// [func@Pango.shape_full].
func ShapeFull(ItemTextVar string, ItemLengthVar int32, ParagraphTextVar string, ParagraphLengthVar int32, AnalysisVar *Analysis, GlyphsVar *GlyphString) {

	xShapeFull(ItemTextVar, ItemLengthVar, ParagraphTextVar, ParagraphLengthVar, AnalysisVar, GlyphsVar)

}

var xShapeItem func(*Item, string, int32, *LogAttr, *GlyphString, ShapeFlags)

// Convert the characters in @item into glyphs.
//
// This is similar to [func@Pango.shape_with_flags], except it takes a
// `PangoItem` instead of separate @item_text and @analysis arguments.
// It also takes @log_attrs, which may be used in implementing text
// transforms.
//
// Note that the extra attributes in the @analyis that is returned from
// [func@Pango.itemize] have indices that are relative to the entire paragraph,
// so you do not pass the full paragraph text as @paragraph_text, you need
// to subtract the item offset from their indices before calling
// [func@Pango.shape_with_flags].
func ShapeItem(ItemVar *Item, ParagraphTextVar string, ParagraphLengthVar int32, LogAttrsVar *LogAttr, GlyphsVar *GlyphString, FlagsVar ShapeFlags) {

	xShapeItem(ItemVar, ParagraphTextVar, ParagraphLengthVar, LogAttrsVar, GlyphsVar, FlagsVar)

}

var xShapeWithFlags func(string, int32, string, int32, *Analysis, *GlyphString, ShapeFlags)

// Convert the characters in @text into glyphs.
//
// Given a segment of text and the corresponding `PangoAnalysis` structure
// returned from [func@Pango.itemize], convert the characters into glyphs.
// You may also pass in only a substring of the item from [func@Pango.itemize].
//
// This is similar to [func@Pango.shape_full], except it also takes flags
// that can influence the shaping process.
//
// Note that the extra attributes in the @analyis that is returned from
// [func@Pango.itemize] have indices that are relative to the entire paragraph,
// so you do not pass the full paragraph text as @paragraph_text, you need
// to subtract the item offset from their indices before calling
// [func@Pango.shape_with_flags].
func ShapeWithFlags(ItemTextVar string, ItemLengthVar int32, ParagraphTextVar string, ParagraphLengthVar int32, AnalysisVar *Analysis, GlyphsVar *GlyphString, FlagsVar ShapeFlags) {

	xShapeWithFlags(ItemTextVar, ItemLengthVar, ParagraphTextVar, ParagraphLengthVar, AnalysisVar, GlyphsVar, FlagsVar)

}

func init() {
	lib, err := purego.Dlopen(core.GetPath("PANGO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}
	core.PuregoSafeRegister(&xShape, lib, "pango_shape")
	core.PuregoSafeRegister(&xShapeFull, lib, "pango_shape_full")
	core.PuregoSafeRegister(&xShapeItem, lib, "pango_shape_item")
	core.PuregoSafeRegister(&xShapeWithFlags, lib, "pango_shape_with_flags")

}
