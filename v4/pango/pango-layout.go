// Package pango was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package pango

import (
	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/internal/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
)

type LayoutClass struct {
}

// A `PangoLayoutIter` can be used to iterate over the visual
// extents of a `PangoLayout`.
//
// To obtain a `PangoLayoutIter`, use [method@Pango.Layout.get_iter].
//
// The `PangoLayoutIter` structure is opaque, and has no user-visible fields.
type LayoutIter struct {
}

// A `PangoLayoutLine` represents one of the lines resulting from laying
// out a paragraph via `PangoLayout`.
//
// `PangoLayoutLine` structures are obtained by calling
// [method@Pango.Layout.get_line] and are only valid until the text,
// attributes, or settings of the parent `PangoLayout` are modified.
type LayoutLine struct {
	Layout *Layout

	StartIndex int32

	Length int32

	Runs *glib.SList

	IsParagraphStart uint

	ResolvedDir uint
}

// A `PangoLayoutRun` represents a single run within a `PangoLayoutLine`.
//
// It is simply an alternate name for [struct@Pango.GlyphItem].
// See the [struct@Pango.GlyphItem] docs for details on the fields.
type LayoutRun = uintptr

// Flags that influence the behavior of [func@Pango.Layout.deserialize].
//
// New members may be added to this enumeration over time.
type LayoutDeserializeFlags int

const (

	// Default behavior
	LayoutDeserializeDefaultValue LayoutDeserializeFlags = 0
	// Apply context information
	//   from the serialization to the `PangoContext`
	LayoutDeserializeContextValue LayoutDeserializeFlags = 1
)

// Flags that influence the behavior of [method@Pango.Layout.serialize].
//
// New members may be added to this enumeration over time.
type LayoutSerializeFlags int

const (

	// Default behavior
	LayoutSerializeDefaultValue LayoutSerializeFlags = 0
	// Include context information
	LayoutSerializeContextValue LayoutSerializeFlags = 1
	// Include information about the formatted output
	LayoutSerializeOutputValue LayoutSerializeFlags = 2
)

// `PangoAlignment` describes how to align the lines of a `PangoLayout`
// within the available space.
//
// If the `PangoLayout` is set to justify using [method@Pango.Layout.set_justify],
// this only affects partial lines.
//
// See [method@Pango.Layout.set_auto_dir] for how text direction affects
// the interpretation of `PangoAlignment` values.
type Alignment int

const (

	// Put all available space on the right
	AlignLeftValue Alignment = 0
	// Center the line within the available space
	AlignCenterValue Alignment = 1
	// Put all available space on the left
	AlignRightValue Alignment = 2
)

// `PangoEllipsizeMode` describes what sort of ellipsization
// should be applied to text.
//
// In the ellipsization process characters are removed from the
// text in order to make it fit to a given width and replaced
// with an ellipsis.
type EllipsizeMode int

const (

	// No ellipsization
	EllipsizeNoneValue EllipsizeMode = 0
	// Omit characters at the start of the text
	EllipsizeStartValue EllipsizeMode = 1
	// Omit characters in the middle of the text
	EllipsizeMiddleValue EllipsizeMode = 2
	// Omit characters at the end of the text
	EllipsizeEndValue EllipsizeMode = 3
)

// Errors that can be returned by [func@Pango.Layout.deserialize].
type LayoutDeserializeError int

const (

	// Unspecified error
	LayoutDeserializeInvalidValue LayoutDeserializeError = 0
	// A JSon value could not be
	//   interpreted
	LayoutDeserializeInvalidValueValue LayoutDeserializeError = 1
	// A required JSon member was
	//   not found
	LayoutDeserializeMissingValueValue LayoutDeserializeError = 2
)

// `PangoWrapMode` describes how to wrap the lines of a `PangoLayout`
// to the desired width.
//
// For @PANGO_WRAP_WORD, Pango uses break opportunities that are determined
// by the Unicode line breaking algorithm. For @PANGO_WRAP_CHAR, Pango allows
// breaking at grapheme boundaries that are determined by the Unicode text
// segmentation algorithm.
type WrapMode int

const (

	// wrap lines at word boundaries.
	WrapWordValue WrapMode = 0
	// wrap lines at character boundaries.
	WrapCharValue WrapMode = 1
	// wrap lines at word boundaries, but fall back to
	//   character boundaries if there is not enough space for a full word.
	WrapWordCharValue WrapMode = 2
)

// A `PangoLayout` structure represents an entire paragraph of text.
//
// While complete access to the layout capabilities of Pango is provided
// using the detailed interfaces for itemization and shaping, using
// that functionality directly involves writing a fairly large amount
// of code. `PangoLayout` provides a high-level driver for formatting
// entire paragraphs of text at once. This includes paragraph-level
// functionality such as line breaking, justification, alignment and
// ellipsization.
//
// A `PangoLayout` is initialized with a `PangoContext`, UTF-8 string
// and set of attributes for that string. Once that is done, the set of
// formatted lines can be extracted from the object, the layout can be
// rendered, and conversion between logical character positions within
// the layout's text, and the physical position of the resulting glyphs
// can be made.
//
// There are a number of parameters to adjust the formatting of a
// `PangoLayout`. The following image shows adjustable parameters
// (on the left) and font metrics (on the right):
//
// &lt;picture&gt;
//
//	&lt;source srcset="layout-dark.png" media="(prefers-color-scheme: dark)"&gt;
//	&lt;img alt="Pango Layout Parameters" src="layout-light.png"&gt;
//
// &lt;/picture&gt;
//
// The following images demonstrate the effect of alignment and
// justification on the layout of text:
//
// | | |
// | --- | --- |
// | ![align=left](align-left.png) | ![align=left, justify](align-left-justify.png) |
// | ![align=center](align-center.png) | ![align=center, justify](align-center-justify.png) |
// | ![align=right](align-right.png) | ![align=right, justify](align-right-justify.png) |
//
// It is possible, as well, to ignore the 2-D setup,
// and simply treat the results of a `PangoLayout` as a list of lines.
type Layout struct {
	gobject.Object
}

func LayoutNewFromInternalPtr(ptr uintptr) *Layout {
	cls := &Layout{}
	cls.Ptr = ptr
	return cls
}

var xNewLayout func(uintptr) uintptr

// Create a new `PangoLayout` object with attributes initialized to
// default values for a particular `PangoContext`.
func NewLayout(ContextVar *Context) *Layout {
	var cls *Layout

	cret := xNewLayout(ContextVar.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &Layout{}
	cls.Ptr = cret
	return cls
}

var xLayoutContextChanged func(uintptr)

// Forces recomputation of any state in the `PangoLayout` that
// might depend on the layout's context.
//
// This function should be called if you make changes to the context
// subsequent to creating the layout.
func (x *Layout) ContextChanged() {

	xLayoutContextChanged(x.GoPointer())

}

var xLayoutCopy func(uintptr) uintptr

// Creates a deep copy-by-value of the layout.
//
// The attribute list, tab array, and text from the original layout
// are all copied by value.
func (x *Layout) Copy() *Layout {
	var cls *Layout

	cret := xLayoutCopy(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &Layout{}
	cls.Ptr = cret
	return cls
}

var xLayoutGetAlignment func(uintptr) Alignment

// Gets the alignment for the layout: how partial lines are
// positioned within the horizontal space available.
func (x *Layout) GetAlignment() Alignment {

	cret := xLayoutGetAlignment(x.GoPointer())
	return cret
}

var xLayoutGetAttributes func(uintptr) *AttrList

// Gets the attribute list for the layout, if any.
func (x *Layout) GetAttributes() *AttrList {

	cret := xLayoutGetAttributes(x.GoPointer())
	return cret
}

var xLayoutGetAutoDir func(uintptr) bool

// Gets whether to calculate the base direction for the layout
// according to its contents.
//
// See [method@Pango.Layout.set_auto_dir].
func (x *Layout) GetAutoDir() bool {

	cret := xLayoutGetAutoDir(x.GoPointer())
	return cret
}

var xLayoutGetBaseline func(uintptr) int

// Gets the Y position of baseline of the first line in @layout.
func (x *Layout) GetBaseline() int {

	cret := xLayoutGetBaseline(x.GoPointer())
	return cret
}

var xLayoutGetCaretPos func(uintptr, int, *Rectangle, *Rectangle)

// Given an index within a layout, determines the positions that of the
// strong and weak cursors if the insertion point is at that index.
//
// This is a variant of [method@Pango.Layout.get_cursor_pos] that applies
// font metric information about caret slope and offset to the positions
// it returns.
//
// &lt;picture&gt;
//
//	&lt;source srcset="caret-metrics-dark.png" media="(prefers-color-scheme: dark)"&gt;
//	&lt;img alt="Caret metrics" src="caret-metrics-light.png"&gt;
//
// &lt;/picture&gt;
func (x *Layout) GetCaretPos(IndexVar int, StrongPosVar *Rectangle, WeakPosVar *Rectangle) {

	xLayoutGetCaretPos(x.GoPointer(), IndexVar, StrongPosVar, WeakPosVar)

}

var xLayoutGetCharacterCount func(uintptr) int

// Returns the number of Unicode characters in the
// the text of @layout.
func (x *Layout) GetCharacterCount() int {

	cret := xLayoutGetCharacterCount(x.GoPointer())
	return cret
}

var xLayoutGetContext func(uintptr) uintptr

// Retrieves the `PangoContext` used for this layout.
func (x *Layout) GetContext() *Context {
	var cls *Context

	cret := xLayoutGetContext(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Context{}
	cls.Ptr = cret
	return cls
}

var xLayoutGetCursorPos func(uintptr, int, *Rectangle, *Rectangle)

// Given an index within a layout, determines the positions that of the
// strong and weak cursors if the insertion point is at that index.
//
// The position of each cursor is stored as a zero-width rectangle
// with the height of the run extents.
//
// &lt;picture&gt;
//
//	&lt;source srcset="cursor-positions-dark.png" media="(prefers-color-scheme: dark)"&gt;
//	&lt;img alt="Cursor positions" src="cursor-positions-light.png"&gt;
//
// &lt;/picture&gt;
//
// The strong cursor location is the location where characters of the
// directionality equal to the base direction of the layout are inserted.
// The weak cursor location is the location where characters of the
// directionality opposite to the base direction of the layout are inserted.
//
// The following example shows text with both a strong and a weak cursor.
//
// &lt;picture&gt;
//
//	&lt;source srcset="split-cursor-dark.png" media="(prefers-color-scheme: dark)"&gt;
//	&lt;img alt="Strong and weak cursors" src="split-cursor-light.png"&gt;
//
// &lt;/picture&gt;
//
// The strong cursor has a little arrow pointing to the right, the weak
// cursor to the left. Typing a 'c' in this situation will insert the
// character after the 'b', and typing another Hebrew character, like 'ג',
// will insert it at the end.
func (x *Layout) GetCursorPos(IndexVar int, StrongPosVar *Rectangle, WeakPosVar *Rectangle) {

	xLayoutGetCursorPos(x.GoPointer(), IndexVar, StrongPosVar, WeakPosVar)

}

var xLayoutGetDirection func(uintptr, int) Direction

// Gets the text direction at the given character position in @layout.
func (x *Layout) GetDirection(IndexVar int) Direction {

	cret := xLayoutGetDirection(x.GoPointer(), IndexVar)
	return cret
}

var xLayoutGetEllipsize func(uintptr) EllipsizeMode

// Gets the type of ellipsization being performed for @layout.
//
// See [method@Pango.Layout.set_ellipsize].
//
// Use [method@Pango.Layout.is_ellipsized] to query whether any
// paragraphs were actually ellipsized.
func (x *Layout) GetEllipsize() EllipsizeMode {

	cret := xLayoutGetEllipsize(x.GoPointer())
	return cret
}

var xLayoutGetExtents func(uintptr, *Rectangle, *Rectangle)

// Computes the logical and ink extents of @layout.
//
// Logical extents are usually what you want for positioning things. Note
// that both extents may have non-zero x and y. You may want to use those
// to offset where you render the layout. Not doing that is a very typical
// bug that shows up as right-to-left layouts not being correctly positioned
// in a layout with a set width.
//
// The extents are given in layout coordinates and in Pango units; layout
// coordinates begin at the top left corner of the layout.
func (x *Layout) GetExtents(InkRectVar *Rectangle, LogicalRectVar *Rectangle) {

	xLayoutGetExtents(x.GoPointer(), InkRectVar, LogicalRectVar)

}

var xLayoutGetFontDescription func(uintptr) *FontDescription

// Gets the font description for the layout, if any.
func (x *Layout) GetFontDescription() *FontDescription {

	cret := xLayoutGetFontDescription(x.GoPointer())
	return cret
}

var xLayoutGetHeight func(uintptr) int

// Gets the height of layout used for ellipsization.
//
// See [method@Pango.Layout.set_height] for details.
func (x *Layout) GetHeight() int {

	cret := xLayoutGetHeight(x.GoPointer())
	return cret
}

var xLayoutGetIndent func(uintptr) int

// Gets the paragraph indent width in Pango units.
//
// A negative value indicates a hanging indentation.
func (x *Layout) GetIndent() int {

	cret := xLayoutGetIndent(x.GoPointer())
	return cret
}

var xLayoutGetIter func(uintptr) *LayoutIter

// Returns an iterator to iterate over the visual extents of the layout.
func (x *Layout) GetIter() *LayoutIter {

	cret := xLayoutGetIter(x.GoPointer())
	return cret
}

var xLayoutGetJustify func(uintptr) bool

// Gets whether each complete line should be stretched to fill the entire
// width of the layout.
func (x *Layout) GetJustify() bool {

	cret := xLayoutGetJustify(x.GoPointer())
	return cret
}

var xLayoutGetJustifyLastLine func(uintptr) bool

// Gets whether the last line should be stretched
// to fill the entire width of the layout.
func (x *Layout) GetJustifyLastLine() bool {

	cret := xLayoutGetJustifyLastLine(x.GoPointer())
	return cret
}

var xLayoutGetLine func(uintptr, int) *LayoutLine

// Retrieves a particular line from a `PangoLayout`.
//
// Use the faster [method@Pango.Layout.get_line_readonly] if you do not
// plan to modify the contents of the line (glyphs, glyph widths, etc.).
func (x *Layout) GetLine(LineVar int) *LayoutLine {

	cret := xLayoutGetLine(x.GoPointer(), LineVar)
	return cret
}

var xLayoutGetLineCount func(uintptr) int

// Retrieves the count of lines for the @layout.
func (x *Layout) GetLineCount() int {

	cret := xLayoutGetLineCount(x.GoPointer())
	return cret
}

var xLayoutGetLineReadonly func(uintptr, int) *LayoutLine

// Retrieves a particular line from a `PangoLayout`.
//
// This is a faster alternative to [method@Pango.Layout.get_line],
// but the user is not expected to modify the contents of the line
// (glyphs, glyph widths, etc.).
func (x *Layout) GetLineReadonly(LineVar int) *LayoutLine {

	cret := xLayoutGetLineReadonly(x.GoPointer(), LineVar)
	return cret
}

var xLayoutGetLineSpacing func(uintptr) float32

// Gets the line spacing factor of @layout.
//
// See [method@Pango.Layout.set_line_spacing].
func (x *Layout) GetLineSpacing() float32 {

	cret := xLayoutGetLineSpacing(x.GoPointer())
	return cret
}

var xLayoutGetLines func(uintptr) *glib.SList

// Returns the lines of the @layout as a list.
//
// Use the faster [method@Pango.Layout.get_lines_readonly] if you do not
// plan to modify the contents of the lines (glyphs, glyph widths, etc.).
func (x *Layout) GetLines() *glib.SList {

	cret := xLayoutGetLines(x.GoPointer())
	return cret
}

var xLayoutGetLinesReadonly func(uintptr) *glib.SList

// Returns the lines of the @layout as a list.
//
// This is a faster alternative to [method@Pango.Layout.get_lines],
// but the user is not expected to modify the contents of the lines
// (glyphs, glyph widths, etc.).
func (x *Layout) GetLinesReadonly() *glib.SList {

	cret := xLayoutGetLinesReadonly(x.GoPointer())
	return cret
}

var xLayoutGetLogAttrs func(uintptr, uintptr, int)

// Retrieves an array of logical attributes for each character in
// the @layout.
func (x *Layout) GetLogAttrs(AttrsVar uintptr, NAttrsVar int) {

	xLayoutGetLogAttrs(x.GoPointer(), AttrsVar, NAttrsVar)

}

var xLayoutGetLogAttrsReadonly func(uintptr, int) uintptr

// Retrieves an array of logical attributes for each character in
// the @layout.
//
// This is a faster alternative to [method@Pango.Layout.get_log_attrs].
// The returned array is part of @layout and must not be modified.
// Modifying the layout will invalidate the returned array.
//
// The number of attributes returned in @n_attrs will be one more
// than the total number of characters in the layout, since there
// need to be attributes corresponding to both the position before
// the first character and the position after the last character.
func (x *Layout) GetLogAttrsReadonly(NAttrsVar int) uintptr {

	cret := xLayoutGetLogAttrsReadonly(x.GoPointer(), NAttrsVar)
	return cret
}

var xLayoutGetPixelExtents func(uintptr, *Rectangle, *Rectangle)

// Computes the logical and ink extents of @layout in device units.
//
// This function just calls [method@Pango.Layout.get_extents] followed by
// two [func@extents_to_pixels] calls, rounding @ink_rect and @logical_rect
// such that the rounded rectangles fully contain the unrounded one (that is,
// passes them as first argument to [func@Pango.extents_to_pixels]).
func (x *Layout) GetPixelExtents(InkRectVar *Rectangle, LogicalRectVar *Rectangle) {

	xLayoutGetPixelExtents(x.GoPointer(), InkRectVar, LogicalRectVar)

}

var xLayoutGetPixelSize func(uintptr, int, int)

// Determines the logical width and height of a `PangoLayout` in device
// units.
//
// [method@Pango.Layout.get_size] returns the width and height
// scaled by %PANGO_SCALE. This is simply a convenience function
// around [method@Pango.Layout.get_pixel_extents].
func (x *Layout) GetPixelSize(WidthVar int, HeightVar int) {

	xLayoutGetPixelSize(x.GoPointer(), WidthVar, HeightVar)

}

var xLayoutGetSerial func(uintptr) uint

// Returns the current serial number of @layout.
//
// The serial number is initialized to an small number larger than zero
// when a new layout is created and is increased whenever the layout is
// changed using any of the setter functions, or the `PangoContext` it
// uses has changed. The serial may wrap, but will never have the value 0.
// Since it can wrap, never compare it with "less than", always use "not equals".
//
// This can be used to automatically detect changes to a `PangoLayout`,
// and is useful for example to decide whether a layout needs redrawing.
// To force the serial to be increased, use
// [method@Pango.Layout.context_changed].
func (x *Layout) GetSerial() uint {

	cret := xLayoutGetSerial(x.GoPointer())
	return cret
}

var xLayoutGetSingleParagraphMode func(uintptr) bool

// Obtains whether @layout is in single paragraph mode.
//
// See [method@Pango.Layout.set_single_paragraph_mode].
func (x *Layout) GetSingleParagraphMode() bool {

	cret := xLayoutGetSingleParagraphMode(x.GoPointer())
	return cret
}

var xLayoutGetSize func(uintptr, int, int)

// Determines the logical width and height of a `PangoLayout` in Pango
// units.
//
// This is simply a convenience function around [method@Pango.Layout.get_extents].
func (x *Layout) GetSize(WidthVar int, HeightVar int) {

	xLayoutGetSize(x.GoPointer(), WidthVar, HeightVar)

}

var xLayoutGetSpacing func(uintptr) int

// Gets the amount of spacing between the lines of the layout.
func (x *Layout) GetSpacing() int {

	cret := xLayoutGetSpacing(x.GoPointer())
	return cret
}

var xLayoutGetTabs func(uintptr) *TabArray

// Gets the current `PangoTabArray` used by this layout.
//
// If no `PangoTabArray` has been set, then the default tabs are
// in use and %NULL is returned. Default tabs are every 8 spaces.
//
// The return value should be freed with [method@Pango.TabArray.free].
func (x *Layout) GetTabs() *TabArray {

	cret := xLayoutGetTabs(x.GoPointer())
	return cret
}

var xLayoutGetText func(uintptr) string

// Gets the text in the layout.
//
// The returned text should not be freed or modified.
func (x *Layout) GetText() string {

	cret := xLayoutGetText(x.GoPointer())
	return cret
}

var xLayoutGetUnknownGlyphsCount func(uintptr) int

// Counts the number of unknown glyphs in @layout.
//
// This function can be used to determine if there are any fonts
// available to render all characters in a certain string, or when
// used in combination with %PANGO_ATTR_FALLBACK, to check if a
// certain font supports all the characters in the string.
func (x *Layout) GetUnknownGlyphsCount() int {

	cret := xLayoutGetUnknownGlyphsCount(x.GoPointer())
	return cret
}

var xLayoutGetWidth func(uintptr) int

// Gets the width to which the lines of the `PangoLayout` should wrap.
func (x *Layout) GetWidth() int {

	cret := xLayoutGetWidth(x.GoPointer())
	return cret
}

var xLayoutGetWrap func(uintptr) WrapMode

// Gets the wrap mode for the layout.
//
// Use [method@Pango.Layout.is_wrapped] to query whether
// any paragraphs were actually wrapped.
func (x *Layout) GetWrap() WrapMode {

	cret := xLayoutGetWrap(x.GoPointer())
	return cret
}

var xLayoutIndexToLineX func(uintptr, int, bool, int, int)

// Converts from byte @index_ within the @layout to line and X position.
//
// The X position is measured from the left edge of the line.
func (x *Layout) IndexToLineX(IndexVar int, TrailingVar bool, LineVar int, XPosVar int) {

	xLayoutIndexToLineX(x.GoPointer(), IndexVar, TrailingVar, LineVar, XPosVar)

}

var xLayoutIndexToPos func(uintptr, int, *Rectangle)

// Converts from an index within a `PangoLayout` to the onscreen position
// corresponding to the grapheme at that index.
//
// The return value is represented as rectangle. Note that `pos-&gt;x` is
// always the leading edge of the grapheme and `pos-&gt;x + pos-&gt;width` the
// trailing edge of the grapheme. If the directionality of the grapheme
// is right-to-left, then `pos-&gt;width` will be negative.
func (x *Layout) IndexToPos(IndexVar int, PosVar *Rectangle) {

	xLayoutIndexToPos(x.GoPointer(), IndexVar, PosVar)

}

var xLayoutIsEllipsized func(uintptr) bool

// Queries whether the layout had to ellipsize any paragraphs.
//
// This returns %TRUE if the ellipsization mode for @layout
// is not %PANGO_ELLIPSIZE_NONE, a positive width is set on @layout,
// and there are paragraphs exceeding that width that have to be
// ellipsized.
func (x *Layout) IsEllipsized() bool {

	cret := xLayoutIsEllipsized(x.GoPointer())
	return cret
}

var xLayoutIsWrapped func(uintptr) bool

// Queries whether the layout had to wrap any paragraphs.
//
// This returns %TRUE if a positive width is set on @layout,
// ellipsization mode of @layout is set to %PANGO_ELLIPSIZE_NONE,
// and there are paragraphs exceeding the layout width that have
// to be wrapped.
func (x *Layout) IsWrapped() bool {

	cret := xLayoutIsWrapped(x.GoPointer())
	return cret
}

var xLayoutMoveCursorVisually func(uintptr, bool, int, int, int, int, int)

// Computes a new cursor position from an old position and a direction.
//
// If @direction is positive, then the new position will cause the strong
// or weak cursor to be displayed one position to right of where it was
// with the old cursor position. If @direction is negative, it will be
// moved to the left.
//
// In the presence of bidirectional text, the correspondence between
// logical and visual order will depend on the direction of the current
// run, and there may be jumps when the cursor is moved off of the end
// of a run.
//
// Motion here is in cursor positions, not in characters, so a single
// call to this function may move the cursor over multiple characters
// when multiple characters combine to form a single grapheme.
func (x *Layout) MoveCursorVisually(StrongVar bool, OldIndexVar int, OldTrailingVar int, DirectionVar int, NewIndexVar int, NewTrailingVar int) {

	xLayoutMoveCursorVisually(x.GoPointer(), StrongVar, OldIndexVar, OldTrailingVar, DirectionVar, NewIndexVar, NewTrailingVar)

}

var xLayoutSerialize func(uintptr, LayoutSerializeFlags) *glib.Bytes

// Serializes the @layout for later deserialization via [func@Pango.Layout.deserialize].
//
// There are no guarantees about the format of the output across different
// versions of Pango and [func@Pango.Layout.deserialize] will reject data
// that it cannot parse.
//
// The intended use of this function is testing, benchmarking and debugging.
// The format is not meant as a permanent storage format.
func (x *Layout) Serialize(FlagsVar LayoutSerializeFlags) *glib.Bytes {

	cret := xLayoutSerialize(x.GoPointer(), FlagsVar)
	return cret
}

var xLayoutSetAlignment func(uintptr, Alignment)

// Sets the alignment for the layout: how partial lines are
// positioned within the horizontal space available.
//
// The default alignment is %PANGO_ALIGN_LEFT.
func (x *Layout) SetAlignment(AlignmentVar Alignment) {

	xLayoutSetAlignment(x.GoPointer(), AlignmentVar)

}

var xLayoutSetAttributes func(uintptr, *AttrList)

// Sets the text attributes for a layout object.
//
// References @attrs, so the caller can unref its reference.
func (x *Layout) SetAttributes(AttrsVar *AttrList) {

	xLayoutSetAttributes(x.GoPointer(), AttrsVar)

}

var xLayoutSetAutoDir func(uintptr, bool)

// Sets whether to calculate the base direction
// for the layout according to its contents.
//
// When this flag is on (the default), then paragraphs in @layout that
// begin with strong right-to-left characters (Arabic and Hebrew principally),
// will have right-to-left layout, paragraphs with letters from other scripts
// will have left-to-right layout. Paragraphs with only neutral characters
// get their direction from the surrounding paragraphs.
//
// When %FALSE, the choice between left-to-right and right-to-left
// layout is done according to the base direction of the layout's
// `PangoContext`. (See [method@Pango.Context.set_base_dir]).
//
// When the auto-computed direction of a paragraph differs from the
// base direction of the context, the interpretation of
// %PANGO_ALIGN_LEFT and %PANGO_ALIGN_RIGHT are swapped.
func (x *Layout) SetAutoDir(AutoDirVar bool) {

	xLayoutSetAutoDir(x.GoPointer(), AutoDirVar)

}

var xLayoutSetEllipsize func(uintptr, EllipsizeMode)

// Sets the type of ellipsization being performed for @layout.
//
// Depending on the ellipsization mode @ellipsize text is
// removed from the start, middle, or end of text so they
// fit within the width and height of layout set with
// [method@Pango.Layout.set_width] and [method@Pango.Layout.set_height].
//
// If the layout contains characters such as newlines that
// force it to be layed out in multiple paragraphs, then whether
// each paragraph is ellipsized separately or the entire layout
// is ellipsized as a whole depends on the set height of the layout.
//
// The default value is %PANGO_ELLIPSIZE_NONE.
//
// See [method@Pango.Layout.set_height] for details.
func (x *Layout) SetEllipsize(EllipsizeVar EllipsizeMode) {

	xLayoutSetEllipsize(x.GoPointer(), EllipsizeVar)

}

var xLayoutSetFontDescription func(uintptr, *FontDescription)

// Sets the default font description for the layout.
//
// If no font description is set on the layout, the
// font description from the layout's context is used.
func (x *Layout) SetFontDescription(DescVar *FontDescription) {

	xLayoutSetFontDescription(x.GoPointer(), DescVar)

}

var xLayoutSetHeight func(uintptr, int)

// Sets the height to which the `PangoLayout` should be ellipsized at.
//
// There are two different behaviors, based on whether @height is positive
// or negative.
//
// If @height is positive, it will be the maximum height of the layout. Only
// lines would be shown that would fit, and if there is any text omitted,
// an ellipsis added. At least one line is included in each paragraph regardless
// of how small the height value is. A value of zero will render exactly one
// line for the entire layout.
//
// If @height is negative, it will be the (negative of) maximum number of lines
// per paragraph. That is, the total number of lines shown may well be more than
// this value if the layout contains multiple paragraphs of text.
// The default value of -1 means that the first line of each paragraph is ellipsized.
// This behavior may be changed in the future to act per layout instead of per
// paragraph. File a bug against pango at
// [https://gitlab.gnome.org/gnome/pango](https://gitlab.gnome.org/gnome/pango)
// if your code relies on this behavior.
//
// Height setting only has effect if a positive width is set on
// @layout and ellipsization mode of @layout is not %PANGO_ELLIPSIZE_NONE.
// The behavior is undefined if a height other than -1 is set and
// ellipsization mode is set to %PANGO_ELLIPSIZE_NONE, and may change in the
// future.
func (x *Layout) SetHeight(HeightVar int) {

	xLayoutSetHeight(x.GoPointer(), HeightVar)

}

var xLayoutSetIndent func(uintptr, int)

// Sets the width in Pango units to indent each paragraph.
//
// A negative value of @indent will produce a hanging indentation.
// That is, the first line will have the full width, and subsequent
// lines will be indented by the absolute value of @indent.
//
// The indent setting is ignored if layout alignment is set to
// %PANGO_ALIGN_CENTER.
//
// The default value is 0.
func (x *Layout) SetIndent(IndentVar int) {

	xLayoutSetIndent(x.GoPointer(), IndentVar)

}

var xLayoutSetJustify func(uintptr, bool)

// Sets whether each complete line should be stretched to fill the
// entire width of the layout.
//
// Stretching is typically done by adding whitespace, but for some scripts
// (such as Arabic), the justification may be done in more complex ways,
// like extending the characters.
//
// Note that this setting is not implemented and so is ignored in
// Pango older than 1.18.
//
// Note that tabs and justification conflict with each other:
// Justification will move content away from its tab-aligned
// positions.
//
// The default value is %FALSE.
//
// Also see [method@Pango.Layout.set_justify_last_line].
func (x *Layout) SetJustify(JustifyVar bool) {

	xLayoutSetJustify(x.GoPointer(), JustifyVar)

}

var xLayoutSetJustifyLastLine func(uintptr, bool)

// Sets whether the last line should be stretched to fill the
// entire width of the layout.
//
// This only has an effect if [method@Pango.Layout.set_justify] has
// been called as well.
//
// The default value is %FALSE.
func (x *Layout) SetJustifyLastLine(JustifyVar bool) {

	xLayoutSetJustifyLastLine(x.GoPointer(), JustifyVar)

}

var xLayoutSetLineSpacing func(uintptr, float32)

// Sets a factor for line spacing.
//
// Typical values are: 0, 1, 1.5, 2. The default values is 0.
//
// If @factor is non-zero, lines are placed so that
//
//	baseline2 = baseline1 + factor * height2
//
// where height2 is the line height of the second line
// (as determined by the font(s)). In this case, the spacing
// set with [method@Pango.Layout.set_spacing] is ignored.
//
// If @factor is zero (the default), spacing is applied as before.
//
// Note: for semantics that are closer to the CSS line-height
// property, see [func@Pango.attr_line_height_new].
func (x *Layout) SetLineSpacing(FactorVar float32) {

	xLayoutSetLineSpacing(x.GoPointer(), FactorVar)

}

var xLayoutSetMarkup func(uintptr, string, int)

// Sets the layout text and attribute list from marked-up text.
//
// See [Pango Markup](pango_markup.html)).
//
// Replaces the current text and attribute list.
//
// This is the same as [method@Pango.Layout.set_markup_with_accel],
// but the markup text isn't scanned for accelerators.
func (x *Layout) SetMarkup(MarkupVar string, LengthVar int) {

	xLayoutSetMarkup(x.GoPointer(), MarkupVar, LengthVar)

}

var xLayoutSetMarkupWithAccel func(uintptr, string, int, uint32, uint32)

// Sets the layout text and attribute list from marked-up text.
//
// See [Pango Markup](pango_markup.html)).
//
// Replaces the current text and attribute list.
//
// If @accel_marker is nonzero, the given character will mark the
// character following it as an accelerator. For example, @accel_marker
// might be an ampersand or underscore. All characters marked
// as an accelerator will receive a %PANGO_UNDERLINE_LOW attribute,
// and the first character so marked will be returned in @accel_char.
// Two @accel_marker characters following each other produce a single
// literal @accel_marker character.
func (x *Layout) SetMarkupWithAccel(MarkupVar string, LengthVar int, AccelMarkerVar uint32, AccelCharVar uint32) {

	xLayoutSetMarkupWithAccel(x.GoPointer(), MarkupVar, LengthVar, AccelMarkerVar, AccelCharVar)

}

var xLayoutSetSingleParagraphMode func(uintptr, bool)

// Sets the single paragraph mode of @layout.
//
// If @setting is %TRUE, do not treat newlines and similar characters
// as paragraph separators; instead, keep all text in a single paragraph,
// and display a glyph for paragraph separator characters. Used when
// you want to allow editing of newlines on a single text line.
//
// The default value is %FALSE.
func (x *Layout) SetSingleParagraphMode(SettingVar bool) {

	xLayoutSetSingleParagraphMode(x.GoPointer(), SettingVar)

}

var xLayoutSetSpacing func(uintptr, int)

// Sets the amount of spacing in Pango units between
// the lines of the layout.
//
// When placing lines with spacing, Pango arranges things so that
//
//	line2.top = line1.bottom + spacing
//
// The default value is 0.
//
// Note: Since 1.44, Pango is using the line height (as determined
// by the font) for placing lines when the line spacing factor is set
// to a non-zero value with [method@Pango.Layout.set_line_spacing].
// In that case, the @spacing set with this function is ignored.
//
// Note: for semantics that are closer to the CSS line-height
// property, see [func@Pango.attr_line_height_new].
func (x *Layout) SetSpacing(SpacingVar int) {

	xLayoutSetSpacing(x.GoPointer(), SpacingVar)

}

var xLayoutSetTabs func(uintptr, *TabArray)

// Sets the tabs to use for @layout, overriding the default tabs.
//
// `PangoLayout` will place content at the next tab position
// whenever it meets a Tab character (U+0009).
//
// By default, tabs are every 8 spaces. If @tabs is %NULL, the
// default tabs are reinstated. @tabs is copied into the layout;
// you must free your copy of @tabs yourself.
//
// Note that tabs and justification conflict with each other:
// Justification will move content away from its tab-aligned
// positions. The same is true for alignments other than
// %PANGO_ALIGN_LEFT.
func (x *Layout) SetTabs(TabsVar *TabArray) {

	xLayoutSetTabs(x.GoPointer(), TabsVar)

}

var xLayoutSetText func(uintptr, string, int)

// Sets the text of the layout.
//
// This function validates @text and renders invalid UTF-8
// with a placeholder glyph.
//
// Note that if you have used [method@Pango.Layout.set_markup] or
// [method@Pango.Layout.set_markup_with_accel] on @layout before, you
// may want to call [method@Pango.Layout.set_attributes] to clear the
// attributes set on the layout from the markup as this function does
// not clear attributes.
func (x *Layout) SetText(TextVar string, LengthVar int) {

	xLayoutSetText(x.GoPointer(), TextVar, LengthVar)

}

var xLayoutSetWidth func(uintptr, int)

// Sets the width to which the lines of the `PangoLayout` should wrap or
// ellipsized.
//
// The default value is -1: no width set.
func (x *Layout) SetWidth(WidthVar int) {

	xLayoutSetWidth(x.GoPointer(), WidthVar)

}

var xLayoutSetWrap func(uintptr, WrapMode)

// Sets the wrap mode.
//
// The wrap mode only has effect if a width is set on the layout
// with [method@Pango.Layout.set_width]. To turn off wrapping,
// set the width to -1.
//
// The default value is %PANGO_WRAP_WORD.
func (x *Layout) SetWrap(WrapVar WrapMode) {

	xLayoutSetWrap(x.GoPointer(), WrapVar)

}

var xLayoutWriteToFile func(uintptr, LayoutSerializeFlags, string, **glib.Error) bool

// A convenience method to serialize a layout to a file.
//
// It is equivalent to calling [method@Pango.Layout.serialize]
// followed by [func@GLib.file_set_contents].
//
// See those two functions for details on the arguments.
//
// It is mostly intended for use inside a debugger to quickly dump
// a layout to a file for later inspection.
func (x *Layout) WriteToFile(FlagsVar LayoutSerializeFlags, FilenameVar string) (bool, error) {
	var cerr *glib.Error

	cret := xLayoutWriteToFile(x.GoPointer(), FlagsVar, FilenameVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xLayoutXyToIndex func(uintptr, int, int, int, int) bool

// Converts from X and Y position within a layout to the byte index to the
// character at that logical position.
//
// If the Y position is not inside the layout, the closest position is
// chosen (the position will be clamped inside the layout). If the X position
// is not within the layout, then the start or the end of the line is
// chosen as described for [method@Pango.LayoutLine.x_to_index]. If either
// the X or Y positions were not inside the layout, then the function returns
// %FALSE; on an exact hit, it returns %TRUE.
func (x *Layout) XyToIndex(XVar int, YVar int, IndexVar int, TrailingVar int) bool {

	cret := xLayoutXyToIndex(x.GoPointer(), XVar, YVar, IndexVar, TrailingVar)
	return cret
}

func (c *Layout) GoPointer() uintptr {
	return c.Ptr
}

func (c *Layout) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

func init() {
	lib, err := purego.Dlopen(core.GetPath("PANGO"), purego.RTLD_NOW|purego.RTLD_GLOBAL)
	if err != nil {
		panic(err)
	}

	core.PuregoSafeRegister(&xNewLayout, lib, "pango_layout_new")

	core.PuregoSafeRegister(&xLayoutContextChanged, lib, "pango_layout_context_changed")
	core.PuregoSafeRegister(&xLayoutCopy, lib, "pango_layout_copy")
	core.PuregoSafeRegister(&xLayoutGetAlignment, lib, "pango_layout_get_alignment")
	core.PuregoSafeRegister(&xLayoutGetAttributes, lib, "pango_layout_get_attributes")
	core.PuregoSafeRegister(&xLayoutGetAutoDir, lib, "pango_layout_get_auto_dir")
	core.PuregoSafeRegister(&xLayoutGetBaseline, lib, "pango_layout_get_baseline")
	core.PuregoSafeRegister(&xLayoutGetCaretPos, lib, "pango_layout_get_caret_pos")
	core.PuregoSafeRegister(&xLayoutGetCharacterCount, lib, "pango_layout_get_character_count")
	core.PuregoSafeRegister(&xLayoutGetContext, lib, "pango_layout_get_context")
	core.PuregoSafeRegister(&xLayoutGetCursorPos, lib, "pango_layout_get_cursor_pos")
	core.PuregoSafeRegister(&xLayoutGetDirection, lib, "pango_layout_get_direction")
	core.PuregoSafeRegister(&xLayoutGetEllipsize, lib, "pango_layout_get_ellipsize")
	core.PuregoSafeRegister(&xLayoutGetExtents, lib, "pango_layout_get_extents")
	core.PuregoSafeRegister(&xLayoutGetFontDescription, lib, "pango_layout_get_font_description")
	core.PuregoSafeRegister(&xLayoutGetHeight, lib, "pango_layout_get_height")
	core.PuregoSafeRegister(&xLayoutGetIndent, lib, "pango_layout_get_indent")
	core.PuregoSafeRegister(&xLayoutGetIter, lib, "pango_layout_get_iter")
	core.PuregoSafeRegister(&xLayoutGetJustify, lib, "pango_layout_get_justify")
	core.PuregoSafeRegister(&xLayoutGetJustifyLastLine, lib, "pango_layout_get_justify_last_line")
	core.PuregoSafeRegister(&xLayoutGetLine, lib, "pango_layout_get_line")
	core.PuregoSafeRegister(&xLayoutGetLineCount, lib, "pango_layout_get_line_count")
	core.PuregoSafeRegister(&xLayoutGetLineReadonly, lib, "pango_layout_get_line_readonly")
	core.PuregoSafeRegister(&xLayoutGetLineSpacing, lib, "pango_layout_get_line_spacing")
	core.PuregoSafeRegister(&xLayoutGetLines, lib, "pango_layout_get_lines")
	core.PuregoSafeRegister(&xLayoutGetLinesReadonly, lib, "pango_layout_get_lines_readonly")
	core.PuregoSafeRegister(&xLayoutGetLogAttrs, lib, "pango_layout_get_log_attrs")
	core.PuregoSafeRegister(&xLayoutGetLogAttrsReadonly, lib, "pango_layout_get_log_attrs_readonly")
	core.PuregoSafeRegister(&xLayoutGetPixelExtents, lib, "pango_layout_get_pixel_extents")
	core.PuregoSafeRegister(&xLayoutGetPixelSize, lib, "pango_layout_get_pixel_size")
	core.PuregoSafeRegister(&xLayoutGetSerial, lib, "pango_layout_get_serial")
	core.PuregoSafeRegister(&xLayoutGetSingleParagraphMode, lib, "pango_layout_get_single_paragraph_mode")
	core.PuregoSafeRegister(&xLayoutGetSize, lib, "pango_layout_get_size")
	core.PuregoSafeRegister(&xLayoutGetSpacing, lib, "pango_layout_get_spacing")
	core.PuregoSafeRegister(&xLayoutGetTabs, lib, "pango_layout_get_tabs")
	core.PuregoSafeRegister(&xLayoutGetText, lib, "pango_layout_get_text")
	core.PuregoSafeRegister(&xLayoutGetUnknownGlyphsCount, lib, "pango_layout_get_unknown_glyphs_count")
	core.PuregoSafeRegister(&xLayoutGetWidth, lib, "pango_layout_get_width")
	core.PuregoSafeRegister(&xLayoutGetWrap, lib, "pango_layout_get_wrap")
	core.PuregoSafeRegister(&xLayoutIndexToLineX, lib, "pango_layout_index_to_line_x")
	core.PuregoSafeRegister(&xLayoutIndexToPos, lib, "pango_layout_index_to_pos")
	core.PuregoSafeRegister(&xLayoutIsEllipsized, lib, "pango_layout_is_ellipsized")
	core.PuregoSafeRegister(&xLayoutIsWrapped, lib, "pango_layout_is_wrapped")
	core.PuregoSafeRegister(&xLayoutMoveCursorVisually, lib, "pango_layout_move_cursor_visually")
	core.PuregoSafeRegister(&xLayoutSerialize, lib, "pango_layout_serialize")
	core.PuregoSafeRegister(&xLayoutSetAlignment, lib, "pango_layout_set_alignment")
	core.PuregoSafeRegister(&xLayoutSetAttributes, lib, "pango_layout_set_attributes")
	core.PuregoSafeRegister(&xLayoutSetAutoDir, lib, "pango_layout_set_auto_dir")
	core.PuregoSafeRegister(&xLayoutSetEllipsize, lib, "pango_layout_set_ellipsize")
	core.PuregoSafeRegister(&xLayoutSetFontDescription, lib, "pango_layout_set_font_description")
	core.PuregoSafeRegister(&xLayoutSetHeight, lib, "pango_layout_set_height")
	core.PuregoSafeRegister(&xLayoutSetIndent, lib, "pango_layout_set_indent")
	core.PuregoSafeRegister(&xLayoutSetJustify, lib, "pango_layout_set_justify")
	core.PuregoSafeRegister(&xLayoutSetJustifyLastLine, lib, "pango_layout_set_justify_last_line")
	core.PuregoSafeRegister(&xLayoutSetLineSpacing, lib, "pango_layout_set_line_spacing")
	core.PuregoSafeRegister(&xLayoutSetMarkup, lib, "pango_layout_set_markup")
	core.PuregoSafeRegister(&xLayoutSetMarkupWithAccel, lib, "pango_layout_set_markup_with_accel")
	core.PuregoSafeRegister(&xLayoutSetSingleParagraphMode, lib, "pango_layout_set_single_paragraph_mode")
	core.PuregoSafeRegister(&xLayoutSetSpacing, lib, "pango_layout_set_spacing")
	core.PuregoSafeRegister(&xLayoutSetTabs, lib, "pango_layout_set_tabs")
	core.PuregoSafeRegister(&xLayoutSetText, lib, "pango_layout_set_text")
	core.PuregoSafeRegister(&xLayoutSetWidth, lib, "pango_layout_set_width")
	core.PuregoSafeRegister(&xLayoutSetWrap, lib, "pango_layout_set_wrap")
	core.PuregoSafeRegister(&xLayoutWriteToFile, lib, "pango_layout_write_to_file")
	core.PuregoSafeRegister(&xLayoutXyToIndex, lib, "pango_layout_xy_to_index")

}
